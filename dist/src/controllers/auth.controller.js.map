{"version":3,"sources":["../../../src/controllers/auth.controller.ts"],"sourcesContent":["import { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\nimport UserModel from '../models/user.model';\nimport { JWT_SECRET, JWT_EXPIRES_IN } from '../config/constants';\nimport { asyncHandler } from '../utils/asyncHandler';\nimport { AppError } from '../utils/AppError';\n\nclass AuthController {\n  // Register new user\n  register = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    console.log('Registration request body:', req.body);\n    const { name, email, password, role, phone } = req.body;\n\n    // Validate input\n    if (!name || !email || !password) {\n      throw new AppError('Missing required fields', 400);\n    }\n\n    // Validate email format\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n      throw new AppError('Invalid email format', 400);\n    }\n\n    // Validate password strength\n    if (password.length < 8) {\n      throw new AppError('Password must be at least 8 characters long', 400);\n    }\n\n    // Check if user already exists with same email AND role\n    const userRole = role || 'DOG_OWNER';\n    const existingUser = await UserModel.findByEmailAndRole(email, userRole);\n    if (existingUser) {\n      // Check if user has OAuth accounts\n      const hasOAuthAccount = await UserModel.hasOAuthAccount(existingUser.id);\n      const hasPassword = !!existingUser.password;\n      \n      if (hasOAuthAccount && !hasPassword) {\n        // User exists with OAuth only\n        throw new AppError('This account is already registered with Google/Apple. Please sign in using the social login option.', 409);\n      } else if (hasPassword) {\n        // User exists with email/password\n        throw new AppError(`An account with this email already exists as ${userRole.replace('_', ' ')}. Please sign in instead.`, 409);\n      } else {\n        // Generic message\n        throw new AppError(`User already exists with this email and role`, 409);\n      }\n    }\n\n    // Check if phone number already exists\n    if (phone) {\n      const existingUserByPhone = await UserModel.findByPhone(phone);\n      if (existingUserByPhone) {\n        throw new AppError('This phone number is already registered with another account. Please use a different phone number or sign in to your existing account.', 409);\n      }\n    }\n\n    // Validate role\n    const validRoles = ['DOG_OWNER', 'FIELD_OWNER', 'ADMIN'];\n    if (role && !validRoles.includes(role)) {\n      throw new AppError('Invalid role specified', 400);\n    }\n\n    // Create user\n    const user = await UserModel.create({\n      name,\n      email,\n      password,\n      role: userRole,\n      phone,\n    });\n\n    // NOTE: Empty field creation removed - fields are now created dynamically\n    // when the field owner first saves their field details.\n    // This prevents orphaned field documents and handles cases where\n    // fields are deleted from the database.\n    \n    // Old code kept for reference:\n    // if (user.role === 'FIELD_OWNER') {\n    //   try {\n    //     const FieldModel = require('../models/field.model').default;\n    //     await FieldModel.create({\n    //       ownerId: user.id,\n    //       fieldDetailsCompleted: false,\n    //       uploadImagesCompleted: false,\n    //       pricingAvailabilityCompleted: false,\n    //       bookingRulesCompleted: false,\n    //       isActive: false,\n    //       amenities: [],\n    //       rules: [],\n    //       images: [],\n    //       operatingDays: []\n    //     });\n    //   } catch (error) {\n    //     console.error('Error creating empty field for field owner:', error);\n    //   }\n    // }\n\n    // Generate JWT token\n    const token = jwt.sign(\n      { \n        id: user.id, \n        email: user.email, \n        role: user.role \n      },\n      JWT_SECRET as jwt.Secret,\n      { \n        expiresIn: JWT_EXPIRES_IN as string | number\n      }\n    );\n\n    res.status(201).json({\n      success: true,\n      message: 'Registration successful',\n      data: {\n        user,\n        token,\n      },\n    });\n  });\n\n  // Login user\n  login = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const { email, password, role } = req.body;\n\n    // Validate input\n    if (!email || !password) {\n      throw new AppError('Email and password are required', 400);\n    }\n\n    // Find user by email and role if role is provided\n    let user;\n    if (role) {\n      user = await UserModel.findByEmailAndRole(email, role);\n      if (!user) {\n        throw new AppError(`No ${role.replace('_', ' ')} account found with this email`, 401);\n      }\n    } else {\n      // If no role specified, find any user with this email\n      // This maintains backward compatibility\n      user = await UserModel.findByEmail(email);\n      if (!user) {\n        throw new AppError('Invalid email or password', 401);\n      }\n    }\n    \n    // Check if user has password (they might only have OAuth)\n    if (!user.password) {\n      const hasOAuthAccount = await UserModel.hasOAuthAccount(user.id);\n      if (hasOAuthAccount) {\n        const providers = await UserModel.getOAuthProviders(user.id);\n        const providerList = providers.map(p => p.charAt(0).toUpperCase() + p.slice(1)).join(' or ');\n        throw new AppError(`This account uses ${providerList} sign-in. Please use the social login button to sign in.`, 401);\n      } else {\n        throw new AppError('Invalid email or password', 401);\n      }\n    }\n\n    // Verify password\n    const isPasswordValid = await UserModel.verifyPassword(password, user.password);\n    if (!isPasswordValid) {\n      throw new AppError('Invalid email or password', 401);\n    }\n\n    // Generate JWT token\n    const token = jwt.sign(\n      { \n        id: user.id, \n        email: user.email, \n        role: user.role \n      },\n      JWT_SECRET as jwt.Secret,\n      { \n        expiresIn: JWT_EXPIRES_IN as string | number\n      }\n    );\n\n    // Remove password from response\n    const { password: _, ...userWithoutPassword } = user;\n\n    res.json({\n      success: true,\n      message: 'Login successful',\n      data: {\n        user: userWithoutPassword,\n        token,\n      },\n    });\n  });\n\n  // Get current user\n  getMe = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const userId = (req as any).user?.id;\n\n    if (!userId) {\n      throw new AppError('User not authenticated', 401);\n    }\n\n    const user = await UserModel.findById(userId);\n    if (!user) {\n      throw new AppError('User not found', 404);\n    }\n\n    res.json({\n      success: true,\n      data: user,\n    });\n  });\n\n  // Logout (if using sessions/cookies)\n  logout = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    // If using cookies, clear them here\n    res.clearCookie('token');\n    \n    res.json({\n      success: true,\n      message: 'Logout successful',\n    });\n  });\n\n  // Refresh token\n  refreshToken = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const { refreshToken } = req.body;\n\n    if (!refreshToken) {\n      throw new AppError('Refresh token is required', 400);\n    }\n\n    try {\n      // Verify refresh token\n      const decoded = jwt.verify(refreshToken, JWT_SECRET) as any;\n      \n      // Generate new access token\n      const newToken = jwt.sign(\n        { \n          id: decoded.id, \n          email: decoded.email, \n          role: decoded.role \n        },\n        JWT_SECRET as jwt.Secret,\n        { expiresIn: JWT_EXPIRES_IN as string | number }\n      );\n\n      res.json({\n        success: true,\n        data: {\n          token: newToken,\n        },\n      });\n    } catch (error) {\n      throw new AppError('Invalid refresh token', 401);\n    }\n  });\n\n  // Social login (Google/Apple)\n  socialLogin = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const { email, name, image, provider, providerId, role } = req.body;\n\n    // Validate input\n    if (!email || !provider || !providerId) {\n      throw new AppError('Missing required fields', 400);\n    }\n\n    // Validate provider\n    const validProviders = ['google', 'apple'];\n    if (!validProviders.includes(provider)) {\n      throw new AppError('Invalid provider', 400);\n    }\n\n    // Validate role if provided\n    const validRoles = ['DOG_OWNER', 'FIELD_OWNER'];\n    if (role && !validRoles.includes(role)) {\n      throw new AppError('Invalid role specified', 400);\n    }\n\n    // Create or update user\n    const user = await UserModel.createOrUpdateSocialUser({\n      email,\n      name,\n      image,\n      provider,\n      providerId,\n      role: role || 'DOG_OWNER',\n    });\n\n    // NOTE: Empty field creation removed - fields are now created dynamically\n    // when the field owner first saves their field details.\n    // See comment in register method for more details.\n\n    // Store OAuth account info\n    const account = await UserModel.hasOAuthAccount(user.id);\n    if (!account) {\n      // Create account record for tracking OAuth provider\n      // This would typically be done in a separate Account model\n      // For now, we're just tracking the provider in the User model\n    }\n\n    // Generate JWT token\n    const token = jwt.sign(\n      { \n        id: user.id, \n        email: user.email, \n        role: user.role,\n        provider: user.provider\n      },\n      JWT_SECRET as jwt.Secret,\n      { \n        expiresIn: JWT_EXPIRES_IN as string | number\n      }\n    );\n\n    res.json({\n      success: true,\n      message: 'Social login successful',\n      data: {\n        user,\n        token,\n      },\n    });\n  });\n\n  // Update user role (for OAuth users who selected role after account creation)\n  updateRole = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const { email, role } = req.body;\n    const userId = (req as any).user?.id;\n\n    // Validate input\n    if (!email || !role) {\n      throw new AppError('Email and role are required', 400);\n    }\n\n    // Validate role\n    const validRoles = ['DOG_OWNER', 'FIELD_OWNER'];\n    if (!validRoles.includes(role)) {\n      throw new AppError('Invalid role specified', 400);\n    }\n\n    // Verify the user is updating their own role\n    const user = await UserModel.findByEmail(email);\n    if (!user) {\n      throw new AppError('User not found', 404);\n    }\n\n    if (user.id !== userId) {\n      throw new AppError('You can only update your own role', 403);\n    }\n\n    // Update the user's role\n    const updatedUser = await UserModel.updateRole(user.id, role);\n\n    // NOTE: Empty field creation removed - fields are now created dynamically\n    // when the field owner first saves their field details.\n    // See comment in register method for more details.\n\n    // Generate new token with updated role\n    const token = jwt.sign(\n      { \n        id: updatedUser.id, \n        email: updatedUser.email, \n        role: updatedUser.role \n      },\n      JWT_SECRET as jwt.Secret,\n      { \n        expiresIn: JWT_EXPIRES_IN as string | number\n      }\n    );\n\n    res.json({\n      success: true,\n      message: 'Role updated successfully',\n      data: {\n        user: updatedUser,\n        token,\n      },\n    });\n  });\n}\n\nexport default new AuthController();"],"names":["AuthController","register","asyncHandler","req","res","next","console","log","body","name","email","password","role","phone","AppError","emailRegex","test","length","userRole","existingUser","UserModel","findByEmailAndRole","hasOAuthAccount","id","hasPassword","replace","existingUserByPhone","findByPhone","validRoles","includes","user","create","token","jwt","sign","JWT_SECRET","expiresIn","JWT_EXPIRES_IN","status","json","success","message","data","login","findByEmail","providers","getOAuthProviders","providerList","map","p","charAt","toUpperCase","slice","join","isPasswordValid","verifyPassword","_","userWithoutPassword","getMe","userId","findById","logout","clearCookie","refreshToken","decoded","verify","newToken","error","socialLogin","image","provider","providerId","validProviders","createOrUpdateSocialUser","account","updateRole","updatedUser"],"mappings":"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"}