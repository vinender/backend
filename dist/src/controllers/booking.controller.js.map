{"version":3,"sources":["../../../src/controllers/booking.controller.ts"],"sourcesContent":["import { Request, Response, NextFunction } from 'express';\nimport BookingModel from '../models/booking.model';\nimport FieldModel from '../models/field.model';\nimport { asyncHandler } from '../utils/asyncHandler';\nimport { AppError } from '../utils/AppError';\nimport prisma from '../config/database';\nimport { createNotification } from './notification.controller';\nimport { payoutService } from '../services/payout.service';\nimport refundService from '../services/refund.service';\n\nclass BookingController {\n  // Create a new booking\n  createBooking = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const dogOwnerId = (req as any).user.id;\n    const { fieldId, date, startTime, endTime, notes, numberOfDogs = 1 } = req.body;\n\n    // Verify field exists and is active\n    const field = await FieldModel.findById(fieldId);\n    if (!field) {\n      throw new AppError('Field not found', 404);\n    }\n\n    if (!field.isActive) {\n      throw new AppError('Field is not available for booking', 400);\n    }\n\n    // Check if the time slot is in the past\n    const bookingDate = new Date(date);\n    const [startHourStr, startPeriod] = startTime.split(/(?=[AP]M)/);\n    let startHour = parseInt(startHourStr.split(':')[0]);\n    if (startPeriod === 'PM' && startHour !== 12) startHour += 12;\n    if (startPeriod === 'AM' && startHour === 12) startHour = 0;\n    \n    const slotDateTime = new Date(bookingDate);\n    slotDateTime.setHours(startHour, parseInt(startHourStr.split(':')[1] || '0'), 0, 0);\n    \n    if (slotDateTime < new Date()) {\n      throw new AppError('Cannot book a time slot in the past', 400);\n    }\n\n    // Check if slot is already booked (private booking system)\n    const startOfDayDate = new Date(bookingDate);\n    startOfDayDate.setHours(0, 0, 0, 0);\n    \n    const endOfDayDate = new Date(bookingDate);\n    endOfDayDate.setHours(23, 59, 59, 999);\n    \n    const existingBooking = await prisma.booking.findFirst({\n      where: {\n        fieldId,\n        date: {\n          gte: startOfDayDate,\n          lte: endOfDayDate\n        },\n        startTime,\n        status: {\n          notIn: ['CANCELLED']\n        }\n      }\n    });\n\n    if (existingBooking) {\n      throw new AppError(\n        'This time slot is already booked. Once booked, a slot becomes private for that dog owner.',\n        400\n      );\n    }\n\n    // Check availability\n    const isAvailable = await BookingModel.checkAvailability(\n      fieldId,\n      new Date(date),\n      startTime,\n      endTime\n    );\n\n    if (!isAvailable) {\n      throw new AppError('This time slot is not available', 400);\n    }\n\n    // Calculate total price based on duration and number of dogs\n    const startMinutes = this.timeToMinutes(startTime);\n    const endMinutes = this.timeToMinutes(endTime);\n    const durationHours = (endMinutes - startMinutes) / 60;\n    const pricePerUnit = field.price || 0;\n    \n    let totalPrice = 0;\n    if (field.bookingDuration === '30min') {\n      // For 30-minute slots, the price is per 30 minutes\n      const duration30MinBlocks = durationHours * 2; // Convert hours to 30-min blocks\n      totalPrice = pricePerUnit * duration30MinBlocks * numberOfDogs;\n    } else {\n      // For hourly slots, price is per hour\n      totalPrice = pricePerUnit * durationHours * numberOfDogs;\n    }\n    \n    // Log for debugging\n    console.log('Create booking price calculation:', {\n      fieldId: field.id,\n      pricePerUnit,\n      durationHours,\n      numberOfDogs,\n      bookingDuration: field.bookingDuration,\n      totalPrice\n    });\n\n    // Create booking\n    const booking = await BookingModel.create({\n      dogOwnerId,\n      fieldId,\n      date: new Date(date),\n      startTime,\n      endTime,\n      timeSlot: `${startTime} - ${endTime}`, // Set timeSlot to match startTime and endTime\n      totalPrice,\n      numberOfDogs, // Store for pricing and info, but slot is now private\n      notes,\n    });\n\n    // Send notification to field owner (if not booking their own field)\n    console.log('=== Booking Notification Debug ===');\n    console.log('Field owner ID:', field.ownerId);\n    console.log('Dog owner ID:', dogOwnerId);\n    console.log('Are they the same?', field.ownerId === dogOwnerId);\n    \n    if (field.ownerId && field.ownerId !== dogOwnerId) {\n      console.log('Sending notification to field owner...');\n      try {\n        await createNotification({\n          userId: field.ownerId,\n          type: 'new_booking_received',\n          title: 'New Booking Received!',\n          message: `You have a new booking request for ${field.name} on ${new Date(date).toLocaleDateString()} from ${startTime} to ${endTime}. Please review and confirm.`,\n          data: {\n            bookingId: booking.id,\n            fieldId: field.id,\n            fieldName: field.name,\n            date,\n            startTime,\n            endTime,\n            dogOwnerName: (req as any).user.name,\n          },\n        });\n        console.log('Field owner notification sent successfully');\n      } catch (error) {\n        console.error('Failed to send field owner notification:', error);\n      }\n    } else {\n      console.log('Skipping field owner notification - booking own field');\n    }\n\n    // Send confirmation notification to dog owner\n    console.log('Sending confirmation notification to dog owner...');\n    try {\n      await createNotification({\n        userId: dogOwnerId,\n        type: 'booking_request_sent',\n        title: 'Booking Request Sent',\n        message: `Your booking request for ${field.name} on ${new Date(date).toLocaleDateString()} has been sent to the field owner. You'll be notified once it's confirmed.`,\n        data: {\n          bookingId: booking.id,\n          fieldId: field.id,\n          fieldName: field.name,\n          date,\n          startTime,\n          endTime,\n          totalPrice,\n        },\n      });\n      console.log('Dog owner confirmation notification sent successfully');\n    } catch (error) {\n      console.error('Failed to send dog owner notification:', error);\n    }\n\n    res.status(201).json({\n      success: true,\n      message: 'Booking created successfully',\n      data: booking,\n    });\n  });\n\n  // Get all bookings (admin only)\n  getAllBookings = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const {\n      dogOwnerId,\n      fieldId,\n      status,\n      date,\n      startDate,\n      endDate,\n      page = 1,\n      limit = 10,\n    } = req.query;\n\n    const skip = (Number(page) - 1) * Number(limit);\n\n    const bookings = await BookingModel.findAll({\n      dogOwnerId: dogOwnerId as string,\n      fieldId: fieldId as string,\n      status: status as any,\n      date: date ? new Date(date as string) : undefined,\n      startDate: startDate ? new Date(startDate as string) : undefined,\n      endDate: endDate ? new Date(endDate as string) : undefined,\n      skip,\n      take: Number(limit),\n    });\n\n    res.json({\n      success: true,\n      data: bookings,\n      pagination: {\n        page: Number(page),\n        limit: Number(limit),\n        total: bookings.length,\n      },\n    });\n  });\n\n  // Get booking by ID\n  getBooking = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const { id } = req.params;\n    const userId = (req as any).user.id;\n    const userRole = (req as any).user.role;\n\n    const booking = await BookingModel.findById(id);\n    if (!booking) {\n      throw new AppError('Booking not found', 404);\n    }\n\n    // Check access rights\n    const hasAccess = \n      userRole === 'ADMIN' ||\n      (booking as any).userId === userId ||\n      (booking.field as any).ownerId === userId;\n\n    if (!hasAccess) {\n      throw new AppError('You do not have access to this booking', 403);\n    }\n\n    res.json({\n      success: true,\n      data: booking,\n    });\n  });\n\n  // Get user's bookings with pagination\n  getMyBookings = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const userId = (req as any).user.id;\n    const userRole = (req as any).user.role;\n    const { status, page = 1, limit = 10, includeExpired, includeFuture } = req.query;\n\n    const pageNum = Number(page);\n    const limitNum = Number(limit);\n    const skip = (pageNum - 1) * limitNum;\n\n    let whereClause: any = {};\n    \n    if (userRole === 'DOG_OWNER') {\n      whereClause.userId = userId;\n    } else if (userRole === 'FIELD_OWNER') {\n      // For field owner, we need to get their field first\n      const fields = await prisma.field.findMany({\n        where: { ownerId: userId },\n        select: { id: true },\n      });\n      \n      if (fields.length === 0) {\n        return res.json({\n          success: true,\n          data: [],\n          pagination: {\n            page: pageNum,\n            limit: limitNum,\n            total: 0,\n            totalPages: 0,\n            hasNextPage: false,\n            hasPrevPage: false,\n          },\n        });\n      }\n      \n      whereClause.fieldId = { in: fields.map(f => f.id) };\n    } else {\n      throw new AppError('Invalid user role', 400);\n    }\n\n    // Handle multiple statuses and date filtering\n    if (status) {\n      const statuses = (status as string).split(',');\n      \n      // If multiple statuses, use OR condition\n      if (statuses.length > 1) {\n        const statusConditions: any[] = [];\n        const now = new Date();\n        \n        for (const s of statuses) {\n          const statusCondition: any = { status: s };\n          \n          // For CANCELLED bookings, filter by date\n          if (s === 'CANCELLED') {\n            if (includeFuture === 'true') {\n              // Upcoming tab: show cancelled bookings with future dates\n              statusCondition.date = { gte: now };\n            } else if (includeExpired === 'true') {\n              // Previous tab: show cancelled bookings with past dates\n              statusCondition.date = { lt: now };\n            }\n          }\n          \n          statusConditions.push(statusCondition);\n        }\n        \n        // For non-cancelled statuses, don't apply date filter\n        const nonCancelledStatuses = statuses.filter(s => s !== 'CANCELLED');\n        if (nonCancelledStatuses.length > 0) {\n          whereClause.OR = [\n            { status: { in: nonCancelledStatuses } },\n            ...statusConditions.filter(sc => sc.status === 'CANCELLED')\n          ];\n        } else {\n          whereClause.OR = statusConditions;\n        }\n      } else {\n        whereClause.status = status as string;\n      }\n    }\n\n    // Get bookings with pagination\n    const [bookings, total] = await Promise.all([\n      prisma.booking.findMany({\n        where: whereClause,\n        skip,\n        take: limitNum,\n        include: {\n          field: {\n            include: {\n              owner: {\n                select: {\n                  id: true,\n                  name: true,\n                  email: true,\n                },\n              },\n            },\n          },\n          user: {\n            select: {\n              id: true,\n              name: true,\n              email: true,\n            },\n          },\n        },\n        orderBy: {\n          createdAt: 'desc',\n        },\n      }),\n      prisma.booking.count({ where: whereClause }),\n    ]);\n\n    const totalPages = Math.ceil(total / limitNum);\n\n    // Automatically mark past CONFIRMED bookings as COMPLETED\n    const now = new Date();\n    const processedBookings = bookings.map((booking) => {\n      // Check if booking is past and still CONFIRMED\n      if (booking.status === 'CONFIRMED' && new Date(booking.date) < now) {\n        // Parse the booking end time to check if the session has ended\n        const bookingDate = new Date(booking.date);\n        const [endHourStr, endPeriod] = booking.endTime.split(/(?=[AP]M)/);\n        let endHour = parseInt(endHourStr.split(':')[0]);\n        const endMinute = parseInt(endHourStr.split(':')[1] || '0');\n        if (endPeriod === 'PM' && endHour !== 12) endHour += 12;\n        if (endPeriod === 'AM' && endHour === 12) endHour = 0;\n        \n        bookingDate.setHours(endHour, endMinute, 0, 0);\n        \n        // If the booking end time has passed, treat it as completed\n        if (bookingDate < now) {\n          return { ...booking, status: 'COMPLETED' };\n        }\n      }\n      return booking;\n    });\n\n    res.json({\n      success: true,\n      data: processedBookings,\n      pagination: {\n        page: pageNum,\n        limit: limitNum,\n        total,\n        totalPages,\n        hasNextPage: pageNum < totalPages,\n        hasPrevPage: pageNum > 1,\n      },\n    });\n  });\n\n  // Update booking status (field owner or admin)\n  updateBookingStatus = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const { id } = req.params;\n    const { status } = req.body;\n    const userId = (req as any).user.id;\n    const userRole = (req as any).user.role;\n\n    const booking = await BookingModel.findById(id);\n    if (!booking) {\n      throw new AppError('Booking not found', 404);\n    }\n\n    // Check authorization\n    const isFieldOwner = (booking.field as any).ownerId === userId;\n    const isAdmin = userRole === 'ADMIN';\n\n    if (!isFieldOwner && !isAdmin) {\n      throw new AppError('You are not authorized to update this booking', 403);\n    }\n\n    // Validate status transition\n    const validTransitions: Record<string, string[]> = {\n      PENDING: ['CONFIRMED', 'CANCELLED'],\n      CONFIRMED: ['COMPLETED', 'CANCELLED'],\n      COMPLETED: [],\n      CANCELLED: [],\n    };\n\n    if (!validTransitions[booking.status].includes(status)) {\n      throw new AppError(`Cannot change status from ${booking.status} to ${status}`, 400);\n    }\n\n    const updatedBooking = await BookingModel.updateStatus(id, status);\n\n    // Send notifications based on status change\n    const field = (booking.field as any);\n    \n    if (status === 'CONFIRMED') {\n      // Notify dog owner that booking is confirmed\n      await createNotification({\n        userId: (booking as any).userId,\n        type: 'booking_confirmed',\n        title: 'Booking Confirmed!',\n        message: `Your booking for ${field.name} on ${new Date(booking.date).toLocaleDateString()} has been confirmed by the field owner.`,\n        data: {\n          bookingId: booking.id,\n          fieldId: field.id,\n          fieldName: field.name,\n          date: booking.date,\n          startTime: booking.startTime,\n          endTime: booking.endTime,\n        },\n      });\n    } else if (status === 'COMPLETED') {\n      // Notify dog owner that booking is completed\n      await createNotification({\n        userId: (booking as any).userId,\n        type: 'booking_completed',\n        title: 'Booking Completed',\n        message: `We hope you enjoyed your visit to ${field.name}. Consider leaving a review!`,\n        data: {\n          bookingId: booking.id,\n          fieldId: field.id,\n          fieldName: field.name,\n        },\n      });\n\n      // Trigger automatic payout to field owner\n      try {\n        console.log(`Triggering automatic payout for completed booking ${id}`);\n        await payoutService.processBookingPayout(id);\n        console.log(`Payout processed successfully for booking ${id}`);\n      } catch (payoutError) {\n        console.error(`Failed to process payout for booking ${id}:`, payoutError);\n        // Don't throw error - payout can be retried later\n        // Notify admin about the failed payout\n        const adminUsers = await prisma.user.findMany({\n          where: { role: 'ADMIN' }\n        });\n        for (const admin of adminUsers) {\n          await createNotification({\n            userId: admin.id,\n            type: 'PAYOUT_FAILED',\n            title: 'Automatic Payout Failed',\n            message: `Failed to process automatic payout for booking ${id}`,\n            data: {\n              bookingId: id,\n              error: payoutError instanceof Error ? payoutError.message : 'Unknown error'\n            }\n          });\n        }\n      }\n    }\n\n    res.json({\n      success: true,\n      message: `Booking ${status.toLowerCase()} successfully`,\n      data: updatedBooking,\n    });\n  });\n\n  // Mark past bookings as completed (can be called by a cron job)\n  markPastBookingsAsCompleted = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const now = new Date();\n    \n    // Find all bookings that are past their date/time and not already completed or cancelled\n    const completedBookings = await prisma.booking.updateMany({\n      where: {\n        status: {\n          notIn: ['COMPLETED', 'CANCELLED'],\n        },\n        date: {\n          lt: now,\n        },\n      },\n      data: {\n        status: 'COMPLETED',\n      },\n    });\n\n    res.json({\n      success: true,\n      message: `Marked ${completedBookings.count} bookings as completed`,\n      data: {\n        count: completedBookings.count,\n      },\n    });\n  });\n\n  // Check refund eligibility for a booking\n  checkRefundEligibility = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const { id } = req.params;\n    const userId = (req as any).user.id;\n\n    // Get cancellation window from settings\n    const settings = await prisma.systemSettings.findFirst();\n    const cancellationWindowHours = settings?.cancellationWindowHours || 24;\n\n    const booking = await BookingModel.findById(id);\n    if (!booking) {\n      throw new AppError('Booking not found', 404);\n    }\n\n    // Check authorization\n    const isDogOwner = (booking as any).userId === userId;\n    if (!isDogOwner) {\n      throw new AppError('You are not authorized to check this booking', 403);\n    }\n\n    // Calculate time until booking from current time\n    const now = new Date();\n    const bookingDate = new Date(booking.date);\n    \n    // Parse the booking start time to add to the date\n    const [startHourStr, startPeriod] = booking.startTime.split(/(?=[AP]M)/);\n    let startHour = parseInt(startHourStr.split(':')[0]);\n    const startMinute = parseInt(startHourStr.split(':')[1] || '0');\n    if (startPeriod === 'PM' && startHour !== 12) startHour += 12;\n    if (startPeriod === 'AM' && startHour === 12) startHour = 0;\n    \n    bookingDate.setHours(startHour, startMinute, 0, 0);\n    \n    // Debug logging\n    console.log('=== Refund Eligibility Check ===');\n    console.log('Booking ID:', booking.id);\n    console.log('Current time:', now.toISOString());\n    console.log('Booking date/time:', bookingDate.toISOString());\n    console.log('Start time:', booking.startTime);\n    \n    // Calculate hours until booking from now\n    const hoursUntilBooking = (bookingDate.getTime() - now.getTime()) / (1000 * 60 * 60);\n    const isRefundEligible = hoursUntilBooking >= cancellationWindowHours;\n    \n    console.log('Hours until booking:', hoursUntilBooking);\n    console.log('Is refund eligible:', isRefundEligible);\n    console.log('=========================');\n\n    res.json({\n      success: true,\n      data: {\n        isRefundEligible,\n        hoursUntilBooking: Math.floor(hoursUntilBooking),\n        canCancel: hoursUntilBooking >= cancellationWindowHours,\n        message: isRefundEligible\n          ? `This booking can be cancelled with a full refund. There are ${Math.floor(hoursUntilBooking)} hours until the booking time.`\n          : `This booking cannot be cancelled with a refund. Cancellations must be made at least ${cancellationWindowHours} hours before the booking time. Only ${Math.floor(hoursUntilBooking)} hours remain.`,\n      },\n    });\n  });\n\n  // Cancel booking (dog owner or field owner)\n  cancelBooking = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const { id } = req.params;\n    const userId = (req as any).user.id;\n    const userRole = (req as any).user.role;\n    const { reason } = req.body;\n\n    // Get cancellation window from settings\n    const settings = await prisma.systemSettings.findFirst();\n    const cancellationWindowHours = settings?.cancellationWindowHours || 24;\n\n    const booking = await BookingModel.findById(id);\n    if (!booking) {\n      throw new AppError('Booking not found', 404);\n    }\n\n    // Check authorization\n    const isDogOwner = (booking as any).userId === userId;\n    const isFieldOwner = (booking.field as any).ownerId === userId;\n    const isAdmin = userRole === 'ADMIN';\n\n    if (!isDogOwner && !isFieldOwner && !isAdmin) {\n      throw new AppError('You are not authorized to cancel this booking', 403);\n    }\n\n    // Check if booking can be cancelled\n    if (booking.status === 'COMPLETED' || booking.status === 'CANCELLED') {\n      throw new AppError(`Cannot cancel a ${booking.status.toLowerCase()} booking`, 400);\n    }\n\n    // Calculate time until booking from current time\n    const now = new Date();\n    const bookingDate = new Date(booking.date);\n    \n    // Parse the booking start time to add to the date\n    const [startHourStr, startPeriod] = booking.startTime.split(/(?=[AP]M)/);\n    let startHour = parseInt(startHourStr.split(':')[0]);\n    const startMinute = parseInt(startHourStr.split(':')[1] || '0');\n    if (startPeriod === 'PM' && startHour !== 12) startHour += 12;\n    if (startPeriod === 'AM' && startHour === 12) startHour = 0;\n    \n    bookingDate.setHours(startHour, startMinute, 0, 0);\n    \n    // Debug logging for cancellation\n    console.log('=== Cancel Booking Check ===');\n    console.log('Booking ID:', booking.id);\n    console.log('Current time:', now.toISOString());\n    console.log('Booking date/time:', bookingDate.toISOString());\n    console.log('Start time:', booking.startTime);\n    \n    // Calculate hours until booking from now\n    const hoursUntilBooking = (bookingDate.getTime() - now.getTime()) / (1000 * 60 * 60);\n    \n    // Check if cancellation is allowed (at least cancellationWindowHours before booking)\n    if (hoursUntilBooking < cancellationWindowHours && !isAdmin) {\n      throw new AppError(`Cancellation not allowed. Bookings must be cancelled at least ${cancellationWindowHours} hours in advance.`, 400);\n    }\n    \n    // Refund is eligible if cancelled at least 24 hours before booking\n    const isRefundEligible = hoursUntilBooking >= cancellationWindowHours;\n    \n    console.log('Hours until booking:', hoursUntilBooking);\n    console.log('Is refund eligible:', isRefundEligible);\n    console.log('===================================');\n\n    const cancelledBooking = await BookingModel.cancel(id, reason);\n\n    // Process immediate refund if eligible\n    let refundResult = null;\n    if (isRefundEligible && isDogOwner) {\n      try {\n        refundResult = await refundService.processRefund(id, reason);\n      } catch (refundError: any) {\n        console.error('Refund processing error:', refundError);\n        // Continue with cancellation even if refund fails\n      }\n    } else if (!isRefundEligible && isDogOwner) {\n      // If not eligible for refund, transfer full amount to field owner after cancellation period\n      try {\n        await refundService.processFieldOwnerPayout(booking, 0);\n      } catch (payoutError: any) {\n        console.error('Payout processing error:', payoutError);\n      }\n    }\n\n    // Send cancellation notifications\n    const field = (booking.field as any);\n    \n    if (isDogOwner) {\n      // Dog owner cancelled - notify field owner\n      if (field.ownerId) {\n        await createNotification({\n          userId: field.ownerId,\n          type: 'booking_cancelled_by_customer',\n          title: 'Booking Cancelled',\n          message: `A booking for ${field.name} on ${new Date(booking.date).toLocaleDateString()} has been cancelled by the customer.`,\n          data: {\n            bookingId: booking.id,\n            fieldId: field.id,\n            fieldName: field.name,\n            date: booking.date,\n            startTime: booking.startTime,\n            endTime: booking.endTime,\n          },\n        });\n      }\n      \n      // Send confirmation to dog owner\n      await createNotification({\n        userId: (booking as any).userId,\n        type: 'booking_cancelled_success',\n        title: 'Booking Cancelled',\n        message: `Your booking for ${field.name} on ${new Date(booking.date).toLocaleDateString()} has been cancelled successfully.`,\n        data: {\n          bookingId: booking.id,\n          fieldId: field.id,\n          fieldName: field.name,\n        },\n      });\n    } else if (isFieldOwner) {\n      // Field owner cancelled - notify dog owner\n      await createNotification({\n        userId: (booking as any).userId,\n        type: 'booking_cancelled_by_owner',\n        title: 'Booking Cancelled by Field Owner',\n        message: `Unfortunately, your booking for ${field.name} on ${new Date(booking.date).toLocaleDateString()} has been cancelled by the field owner.`,\n        data: {\n          bookingId: booking.id,\n          fieldId: field.id,\n          fieldName: field.name,\n          date: booking.date,\n        },\n      });\n    }\n\n    res.json({\n      success: true,\n      message: 'Booking cancelled successfully',\n      data: {\n        ...cancelledBooking,\n        isRefundEligible,\n        refundResult,\n        refundMessage: refundResult?.success \n          ? `Refund of $${refundResult.refundAmount?.toFixed(2) || '0.00'} has been initiated and will be credited to your account within 5-7 business days.`\n          : isRefundEligible\n            ? 'You are eligible for a refund. The amount will be credited to your account within 5-7 business days.'\n            : `This booking is not eligible for a refund as it was cancelled less than ${cancellationWindowHours} hours before the scheduled time.`,\n      },\n    });\n  });\n\n  // Update booking (reschedule)\n  updateBooking = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const { id } = req.params;\n    const { date, startTime, endTime, notes } = req.body;\n    const userId = (req as any).user.id;\n\n    const booking = await BookingModel.findById(id);\n    if (!booking) {\n      throw new AppError('Booking not found', 404);\n    }\n\n    // Only dog owner can reschedule their booking\n    if ((booking as any).userId !== userId) {\n      throw new AppError('You can only update your own bookings', 403);\n    }\n\n    // Check if booking can be rescheduled\n    if (booking.status !== 'PENDING' && booking.status !== 'CONFIRMED') {\n      throw new AppError('Only pending or confirmed bookings can be rescheduled', 400);\n    }\n\n    // If changing time/date, check availability and recalculate price\n    if (date || startTime || endTime) {\n      const newDate = date ? new Date(date) : booking.date;\n      const newStartTime = startTime || booking.startTime;\n      const newEndTime = endTime || booking.endTime;\n\n      const isAvailable = await BookingModel.checkAvailability(\n        booking.fieldId,\n        newDate,\n        newStartTime,\n        newEndTime,\n        id // Exclude current booking from check\n      );\n\n      if (!isAvailable) {\n        throw new AppError('The new time slot is not available', 400);\n      }\n\n      // Always recalculate price when rescheduling with the original numberOfDogs\n      const field = await FieldModel.findById(booking.fieldId);\n      if (!field) {\n        throw new AppError('Field not found', 404);\n      }\n      \n      const startMinutes = this.timeToMinutes(newStartTime);\n      const endMinutes = this.timeToMinutes(newEndTime);\n      const durationHours = (endMinutes - startMinutes) / 60;\n      const dogsCount = booking.numberOfDogs || 1; // Always use the original numberOfDogs from booking\n      \n      // Calculate price based on field's booking duration setting\n      let pricePerUnit = field.price || 0;\n      let totalPrice = 0;\n      \n      if (field.bookingDuration === '30min') {\n        // For 30-minute slots, the price is per 30 minutes\n        const duration30MinBlocks = durationHours * 2; // Convert hours to 30-min blocks\n        totalPrice = pricePerUnit * duration30MinBlocks * dogsCount;\n      } else {\n        // For hourly slots, price is per hour\n        totalPrice = pricePerUnit * durationHours * dogsCount;\n      }\n      \n      // Ensure totalPrice is a valid number\n      if (isNaN(totalPrice) || totalPrice < 0) {\n        console.error('Invalid totalPrice calculation:', {\n          pricePerUnit,\n          durationHours,\n          numberOfDogs: dogsCount,\n          bookingDuration: field.bookingDuration,\n          totalPrice\n        });\n        totalPrice = 0;\n      }\n      \n      // Log for debugging\n      console.log('Reschedule price calculation:', {\n        pricePerUnit,\n        durationHours,\n        numberOfDogs: dogsCount,\n        bookingDuration: field.bookingDuration,\n        totalPrice\n      });\n\n      // Ensure totalPrice is set in the update data\n      req.body.totalPrice = totalPrice;\n      \n      // Update timeSlot to match the new startTime and endTime\n      req.body.timeSlot = `${newStartTime} - ${newEndTime}`;\n      \n      // Convert date string to full DateTime if provided\n      if (date) {\n        req.body.date = new Date(date);\n      }\n    }\n\n    // Log the final update data\n    console.log('Final update data for booking:', req.body);\n\n    const updatedBooking = await BookingModel.update(id, req.body);\n\n    res.json({\n      success: true,\n      message: 'Booking updated successfully',\n      data: updatedBooking,\n    });\n  });\n\n  // Delete booking (admin only)\n  deleteBooking = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const { id } = req.params;\n\n    const booking = await BookingModel.findById(id);\n    if (!booking) {\n      throw new AppError('Booking not found', 404);\n    }\n\n    await BookingModel.delete(id);\n\n    res.status(204).json({\n      success: true,\n      message: 'Booking deleted successfully',\n    });\n  });\n\n  // Get booking statistics\n  getBookingStats = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const userId = (req as any).user.id;\n    const userRole = (req as any).user.role;\n\n    let stats;\n    if (userRole === 'DOG_OWNER') {\n      stats = await BookingModel.getDogOwnerStats(userId);\n    } else if (userRole === 'FIELD_OWNER') {\n      stats = await BookingModel.getFieldOwnerStats(userId);\n    } else {\n      throw new AppError('Statistics not available for this user role', 400);\n    }\n\n    res.json({\n      success: true,\n      data: stats,\n    });\n  });\n\n  // Get slot availability (private booking system - slot is either available or booked)\n  getSlotAvailability = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const { fieldId } = req.params;\n    const { date } = req.query;\n\n    if (!date) {\n      throw new AppError('Date is required', 400);\n    }\n\n    // Get field details\n    const field = await prisma.field.findUnique({\n      where: { id: fieldId }\n    });\n\n    if (!field) {\n      throw new AppError('Field not found', 404);\n    }\n\n    // Parse the date\n    const selectedDate = new Date(date as string);\n    const now = new Date();\n\n    // Get start and end of day\n    const startOfDayDate = new Date(selectedDate);\n    startOfDayDate.setHours(0, 0, 0, 0);\n    \n    const endOfDayDate = new Date(selectedDate);\n    endOfDayDate.setHours(23, 59, 59, 999);\n\n    // Get all bookings for this field on the selected date (excluding cancelled)\n    const bookings = await prisma.booking.findMany({\n      where: {\n        fieldId,\n        date: {\n          gte: startOfDayDate,\n          lte: endOfDayDate\n        },\n        status: {\n          notIn: ['CANCELLED']\n        }\n      },\n      select: {\n        startTime: true,\n        endTime: true,\n        timeSlot: true,\n        status: true\n      }\n    });\n\n    // Generate time slots based on field's operating hours and booking duration\n    const openingHour = field.openingTime ? parseInt(field.openingTime.split(':')[0]) : 6;\n    const closingHour = field.closingTime ? parseInt(field.closingTime.split(':')[0]) : 21;\n\n    const slots = [];\n    \n    // Determine slot duration based on field's bookingDuration\n    const slotDurationMinutes = field.bookingDuration === '30min' ? 30 : 60;\n    \n    // Helper function to format time\n    const formatTime = (hour: number, minutes: number = 0): string => {\n      const period = hour >= 12 ? 'PM' : 'AM';\n      const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;\n      const displayMinutes = minutes.toString().padStart(2, '0');\n      return `${displayHour}:${displayMinutes}${period}`;\n    };\n\n    // Generate slots based on duration\n    if (slotDurationMinutes === 30) {\n      // Generate 30-minute slots\n      for (let hour = openingHour; hour < closingHour; hour++) {\n        for (let minutes = 0; minutes < 60; minutes += 30) {\n          const endMinutes = minutes + 30;\n          const endHour = endMinutes === 60 ? hour + 1 : hour;\n          const actualEndMinutes = endMinutes === 60 ? 0 : endMinutes;\n          \n          // Don't create slots that go beyond closing time\n          if (endHour > closingHour || (endHour === closingHour && actualEndMinutes > 0)) {\n            break;\n          }\n          \n          const startTime = formatTime(hour, minutes);\n          const endTime = formatTime(endHour, actualEndMinutes);\n          const slotTime = `${startTime} - ${endTime}`;\n          \n          // Check if this slot is in the past\n          const slotDateTime = new Date(selectedDate);\n          slotDateTime.setHours(hour, minutes, 0, 0);\n          const isPast = slotDateTime < now;\n          \n          // Check if slot is booked (private booking system)\n          const isBooked = bookings.some(\n            booking => booking.timeSlot === slotTime || booking.startTime === startTime\n          );\n          \n          slots.push({\n            time: slotTime,\n            startHour: hour,\n            isPast,\n            isBooked,\n            isAvailable: !isPast && !isBooked\n          });\n        }\n      }\n    } else {\n      // Generate 1-hour slots\n      for (let hour = openingHour; hour < closingHour; hour++) {\n        const startTime = formatTime(hour);\n        const endTime = formatTime(hour + 1);\n        const slotTime = `${startTime} - ${endTime}`;\n\n        // Check if this slot is in the past\n        const slotDateTime = new Date(selectedDate);\n        slotDateTime.setHours(hour, 0, 0, 0);\n        const isPast = slotDateTime < now;\n\n        // Check if slot is booked (private booking system)\n        const isBooked = bookings.some(\n          booking => booking.timeSlot === slotTime || booking.startTime === startTime\n        );\n\n        slots.push({\n          time: slotTime,\n          startHour: hour,\n          isPast,\n          isBooked,\n          isAvailable: !isPast && !isBooked\n        });\n      }\n    }\n\n    res.json({\n      success: true,\n      data: {\n        date: date as string,\n        fieldId,\n        fieldName: field.name,\n        slots,\n        bookingDuration: field.bookingDuration || '1hour',\n        operatingHours: {\n          opening: field.openingTime || '06:00',\n          closing: field.closingTime || '21:00'\n        },\n        operatingDays: field.operatingDays\n      }\n    });\n  });\n\n  // Check field availability\n  checkAvailability = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const { fieldId, date, startTime, endTime } = req.query;\n\n    if (!fieldId || !date || !startTime || !endTime) {\n      throw new AppError('Field ID, date, start time, and end time are required', 400);\n    }\n\n    const isAvailable = await BookingModel.checkAvailability(\n      fieldId as string,\n      new Date(date as string),\n      startTime as string,\n      endTime as string\n    );\n\n    res.json({\n      success: true,\n      available: isAvailable,\n    });\n  });\n\n  // Get my recurring bookings (subscriptions + bookings with repeatBooking)\n  getMyRecurringBookings = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const userId = (req as any).user.id;\n    const { status = 'active' } = req.query;\n\n    // Get both subscriptions and bookings with repeatBooking !== 'none'\n    const [subscriptions, recurringBookings] = await Promise.all([\n      // Get user's subscriptions from subscription table\n      prisma.subscription.findMany({\n        where: {\n          userId,\n          ...(status && { status: status as string })\n        },\n        include: {\n          field: {\n            include: {\n              owner: {\n                select: {\n                  id: true,\n                  name: true,\n                  email: true\n                }\n              }\n            }\n          },\n          bookings: {\n            take: 5,\n            orderBy: {\n              date: 'desc'\n            }\n          }\n        },\n        orderBy: {\n          createdAt: 'desc'\n        }\n      }),\n      // Get regular bookings with repeatBooking set (handle case variations)\n      prisma.booking.findMany({\n        where: {\n          userId,\n          AND: [\n            {\n              repeatBooking: {\n                not: null\n              }\n            },\n            {\n              repeatBooking: {\n                notIn: ['none', 'None', 'NONE', '']\n              }\n            }\n          ],\n          status: status === 'active' ? 'CONFIRMED' : { in: ['CANCELLED', 'COMPLETED'] }\n        },\n        include: {\n          field: {\n            include: {\n              owner: {\n                select: {\n                  id: true,\n                  name: true,\n                  email: true\n                }\n              }\n            }\n          },\n          payment: true\n        },\n        orderBy: {\n          createdAt: 'desc'\n        }\n      })\n    ]);\n\n    // Format subscriptions\n    const formattedSubscriptions = subscriptions.map(sub => ({\n      id: sub.id,\n      type: 'subscription',\n      fieldId: sub.fieldId,\n      fieldName: sub.field.name,\n      fieldAddress: sub.field.address,\n      fieldOwner: sub.field.owner.name,\n      interval: sub.interval,\n      dayOfWeek: sub.dayOfWeek,\n      dayOfMonth: sub.dayOfMonth,\n      timeSlot: sub.timeSlot,\n      startTime: sub.startTime,\n      endTime: sub.endTime,\n      numberOfDogs: sub.numberOfDogs,\n      totalPrice: sub.totalPrice,\n      status: sub.status,\n      nextBillingDate: sub.nextBillingDate,\n      currentPeriodEnd: sub.currentPeriodEnd,\n      cancelAtPeriodEnd: sub.cancelAtPeriodEnd,\n      canceledAt: sub.canceledAt,\n      recentBookings: sub.bookings.map(booking => ({\n        id: booking.id,\n        date: booking.date,\n        status: booking.status,\n        paymentStatus: booking.paymentStatus\n      })),\n      createdAt: sub.createdAt\n    }));\n\n    // Format regular bookings with repeatBooking\n    const formattedRecurringBookings = recurringBookings.map(booking => ({\n      id: booking.id,\n      type: 'booking',\n      fieldId: booking.fieldId,\n      fieldName: booking.field.name,\n      fieldAddress: booking.field.address,\n      fieldOwner: booking.field.owner.name || booking.field.owner.email,\n      interval: booking.repeatBooking, // 'weekly' or 'monthly'\n      dayOfWeek: null, // Could extract from date if needed\n      dayOfMonth: null,\n      timeSlot: booking.timeSlot,\n      startTime: booking.startTime,\n      endTime: booking.endTime,\n      numberOfDogs: booking.numberOfDogs,\n      totalPrice: booking.totalPrice,\n      status: booking.status === 'CONFIRMED' ? 'active' : booking.status.toLowerCase(),\n      nextBillingDate: booking.date, // Use booking date\n      currentPeriodEnd: booking.date,\n      cancelAtPeriodEnd: false,\n      canceledAt: booking.cancelledAt,\n      recentBookings: [{\n        id: booking.id,\n        date: booking.date,\n        status: booking.status,\n        paymentStatus: booking.paymentStatus\n      }],\n      createdAt: booking.createdAt,\n      repeatBooking: booking.repeatBooking // Include original field\n    }));\n\n    // Combine both lists\n    const allRecurringBookings = [...formattedSubscriptions, ...formattedRecurringBookings];\n\n    // Sort by creation date (newest first)\n    allRecurringBookings.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    res.json({\n      success: true,\n      data: allRecurringBookings,\n      total: allRecurringBookings.length,\n      breakdown: {\n        subscriptions: formattedSubscriptions.length,\n        recurringBookings: formattedRecurringBookings.length\n      }\n    });\n  });\n\n  // Cancel recurring booking (subscription)\n  cancelRecurringBooking = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {\n    const userId = (req as any).user.id;\n    const { id: subscriptionId } = req.params;\n    const { cancelImmediately = false } = req.body;\n\n    // Find the subscription\n    const subscription = await prisma.subscription.findUnique({\n      where: {\n        id: subscriptionId\n      },\n      include: {\n        field: true\n      }\n    });\n\n    if (!subscription) {\n      throw new AppError('Recurring booking not found', 404);\n    }\n\n    // Verify ownership\n    if (subscription.userId !== userId) {\n      throw new AppError('You are not authorized to cancel this recurring booking', 403);\n    }\n\n    // Cancel in Stripe if subscription exists\n    if (subscription.stripeSubscriptionId) {\n      try {\n        const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);\n        \n        if (cancelImmediately) {\n          // Cancel immediately and issue prorated refund\n          await stripe.subscriptions.cancel(subscription.stripeSubscriptionId);\n        } else {\n          // Cancel at period end\n          await stripe.subscriptions.update(subscription.stripeSubscriptionId, {\n            cancel_at_period_end: true\n          });\n        }\n      } catch (stripeError: any) {\n        console.error('Stripe cancellation error:', stripeError);\n        // Continue with local cancellation even if Stripe fails\n      }\n    }\n\n    // Update subscription in database\n    const updatedSubscription = await prisma.subscription.update({\n      where: {\n        id: subscriptionId\n      },\n      data: {\n        status: cancelImmediately ? 'canceled' : subscription.status,\n        cancelAtPeriodEnd: !cancelImmediately,\n        canceledAt: cancelImmediately ? new Date() : null\n      }\n    });\n\n    // Cancel future bookings if canceling immediately\n    if (cancelImmediately) {\n      await prisma.booking.updateMany({\n        where: {\n          subscriptionId,\n          date: {\n            gte: new Date()\n          },\n          status: {\n            in: ['PENDING', 'CONFIRMED']\n          }\n        },\n        data: {\n          status: 'CANCELLED',\n          cancellationReason: 'Recurring booking canceled',\n          cancelledAt: new Date()\n        }\n      });\n    }\n\n    // Create notification for user\n    await createNotification({\n      userId,\n      type: 'booking_cancelled',\n      title: 'Recurring Booking Canceled',\n      message: cancelImmediately \n        ? `Your recurring booking for ${subscription.field.name} has been canceled immediately.`\n        : `Your recurring booking for ${subscription.field.name} will be canceled at the end of the current period.`,\n      metadata: {\n        subscriptionId,\n        fieldId: subscription.fieldId,\n        cancelType: cancelImmediately ? 'immediate' : 'period_end'\n      }\n    });\n\n    // Create notification for field owner\n    await createNotification({\n      userId: subscription.field.ownerId,\n      type: 'booking_cancelled',\n      title: 'Recurring Booking Canceled',\n      message: cancelImmediately\n        ? `A recurring booking for ${subscription.field.name} has been canceled.`\n        : `A recurring booking for ${subscription.field.name} will end after the current period.`,\n      metadata: {\n        subscriptionId,\n        fieldId: subscription.fieldId,\n        cancelType: cancelImmediately ? 'immediate' : 'period_end'\n      }\n    });\n\n    res.json({\n      success: true,\n      message: cancelImmediately \n        ? 'Recurring booking canceled immediately' \n        : 'Recurring booking will be canceled at the end of the current period',\n      data: updatedSubscription\n    });\n  });\n\n  // Helper function\n  private timeToMinutes(time: string): number {\n    const [hours, minutes] = time.split(':').map(Number);\n    return hours * 60 + minutes;\n  }\n}\n\nexport default new BookingController();"],"names":["BookingController","createBooking","asyncHandler","req","res","next","dogOwnerId","user","id","fieldId","date","startTime","endTime","notes","numberOfDogs","body","field","FieldModel","findById","AppError","isActive","bookingDate","Date","startHourStr","startPeriod","split","startHour","parseInt","slotDateTime","setHours","startOfDayDate","endOfDayDate","existingBooking","prisma","booking","findFirst","where","gte","lte","status","notIn","isAvailable","BookingModel","checkAvailability","startMinutes","timeToMinutes","endMinutes","durationHours","pricePerUnit","price","totalPrice","bookingDuration","duration30MinBlocks","console","log","create","timeSlot","ownerId","createNotification","userId","type","title","message","name","toLocaleDateString","data","bookingId","fieldName","dogOwnerName","error","json","success","getAllBookings","startDate","endDate","page","limit","query","skip","Number","bookings","findAll","undefined","take","pagination","total","length","getBooking","params","userRole","role","hasAccess","getMyBookings","includeExpired","includeFuture","pageNum","limitNum","whereClause","fields","findMany","select","totalPages","hasNextPage","hasPrevPage","in","map","f","statuses","statusConditions","now","s","statusCondition","lt","push","nonCancelledStatuses","filter","OR","sc","Promise","all","include","owner","email","orderBy","createdAt","count","Math","ceil","processedBookings","endHourStr","endPeriod","endHour","endMinute","updateBookingStatus","isFieldOwner","isAdmin","validTransitions","PENDING","CONFIRMED","COMPLETED","CANCELLED","includes","updatedBooking","updateStatus","payoutService","processBookingPayout","payoutError","adminUsers","admin","Error","toLowerCase","markPastBookingsAsCompleted","completedBookings","updateMany","checkRefundEligibility","settings","systemSettings","cancellationWindowHours","isDogOwner","startMinute","toISOString","hoursUntilBooking","getTime","isRefundEligible","floor","canCancel","cancelBooking","reason","cancelledBooking","cancel","refundResult","refundService","processRefund","refundError","processFieldOwnerPayout","refundMessage","refundAmount","toFixed","updateBooking","newDate","newStartTime","newEndTime","dogsCount","isNaN","update","deleteBooking","delete","getBookingStats","stats","getDogOwnerStats","getFieldOwnerStats","getSlotAvailability","findUnique","selectedDate","openingHour","openingTime","closingHour","closingTime","slots","slotDurationMinutes","formatTime","hour","minutes","period","displayHour","displayMinutes","toString","padStart","actualEndMinutes","slotTime","isPast","isBooked","some","time","operatingHours","opening","closing","operatingDays","available","getMyRecurringBookings","subscriptions","recurringBookings","subscription","AND","repeatBooking","not","payment","formattedSubscriptions","sub","fieldAddress","address","fieldOwner","interval","dayOfWeek","dayOfMonth","nextBillingDate","currentPeriodEnd","cancelAtPeriodEnd","canceledAt","recentBookings","paymentStatus","formattedRecurringBookings","cancelledAt","allRecurringBookings","sort","a","b","breakdown","cancelRecurringBooking","subscriptionId","cancelImmediately","stripeSubscriptionId","stripe","require","process","env","STRIPE_SECRET_KEY","cancel_at_period_end","stripeError","updatedSubscription","cancellationReason","metadata","cancelType","hours"],"mappings":"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"}