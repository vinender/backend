{"version":3,"sources":["../../../src/controllers/claim.controller.ts"],"sourcesContent":["import { Request, Response } from 'express';\nimport { PrismaClient } from '@prisma/client';\nimport { asyncHandler } from '../utils/asyncHandler';\nimport { AppError } from '../utils/AppError';\nimport { emailService } from '../services/email.service';\n\nconst prisma = new PrismaClient();\n\n// Submit a field claim\nexport const submitFieldClaim = asyncHandler(async (req: Request, res: Response) => {\n  const {\n    fieldId,\n    fullName,\n    email,\n    phoneCode,\n    phoneNumber,\n    isLegalOwner,\n    documents\n  } = req.body;\n\n  // Validate required fields\n  if (!fieldId || !fullName || !email || !phoneNumber || isLegalOwner === undefined || !documents || documents.length === 0) {\n    throw new AppError('All fields are required', 400);\n  }\n\n  // Check if field exists\n  const field = await prisma.field.findUnique({\n    where: { id: fieldId }\n  });\n\n  if (!field) {\n    throw new AppError('Field not found', 404);\n  }\n\n  // Check if field is already claimed (approved)\n  if (field.isClaimed) {\n    throw new AppError('This field has already been claimed and verified', 400);\n  }\n\n  // Check if there's already an APPROVED claim for this field\n  const approvedClaim = await prisma.fieldClaim.findFirst({\n    where: {\n      fieldId,\n      status: 'APPROVED'\n    }\n  });\n\n  if (approvedClaim) {\n    throw new AppError('This field has already been claimed and approved', 400);\n  }\n\n  // Check if this specific user already has a pending claim for this field\n  const existingUserClaim = await prisma.fieldClaim.findFirst({\n    where: {\n      fieldId,\n      email,\n      status: 'PENDING'\n    }\n  });\n\n  if (existingUserClaim) {\n    throw new AppError('You already have a pending claim for this field. Please wait for the review to complete.', 400);\n  }\n\n  // Create the claim\n  const claim = await prisma.fieldClaim.create({\n    data: {\n      fieldId,\n      fullName,\n      email,\n      phoneCode,\n      phoneNumber,\n      isLegalOwner,\n      documents,\n      status: 'PENDING'\n    },\n    include: {\n      field: {\n        select: {\n          id: true,\n          name: true,\n          address: true,\n          city: true,\n          state: true\n        }\n      }\n    }\n  });\n\n  // Send confirmation email to the claimer\n  try {\n    const fieldAddress = field.address ? \n      `${field.address}${field.city ? ', ' + field.city : ''}${field.state ? ', ' + field.state : ''}` : \n      'Address not specified';\n    \n    const fullPhoneNumber = `${phoneCode} ${phoneNumber}`;\n    \n    await emailService.sendFieldClaimEmail({\n      fullName,\n      email,\n      phoneNumber: fullPhoneNumber,\n      fieldName: field.name || 'Unnamed Field',\n      fieldAddress: fieldAddress,\n      isLegalOwner,\n      submittedAt: claim.createdAt,\n      documents: documents // Pass the documents array\n    });\n  } catch (emailError) {\n    // Log error but don't fail the claim submission\n    console.error('Failed to send field claim email:', emailError);\n  }\n\n  res.status(201).json({\n    success: true,\n    message: 'Claim submitted successfully. A confirmation email has been sent to your registered email address.',\n    data: claim\n  });\n});\n\n// Get all claims (admin only)\nexport const getAllClaims = asyncHandler(async (req: Request, res: Response) => {\n  const { status, page = 1, limit = 10 } = req.query;\n  const skip = (Number(page) - 1) * Number(limit);\n\n  const where: any = {};\n  if (status) {\n    where.status = status;\n  }\n\n  const [claims, total] = await Promise.all([\n    prisma.fieldClaim.findMany({\n      where,\n      include: {\n        field: {\n          select: {\n            id: true,\n            name: true,\n            address: true,\n            city: true,\n            state: true\n          }\n        }\n      },\n      orderBy: {\n        createdAt: 'desc'\n      },\n      skip,\n      take: Number(limit)\n    }),\n    prisma.fieldClaim.count({ where })\n  ]);\n\n  res.json({\n    success: true,\n    data: claims,\n    pagination: {\n      page: Number(page),\n      limit: Number(limit),\n      total,\n      totalPages: Math.ceil(total / Number(limit))\n    }\n  });\n});\n\n// Get claim by ID\nexport const getClaimById = asyncHandler(async (req: Request, res: Response) => {\n  const { claimId } = req.params;\n\n  const claim = await prisma.fieldClaim.findUnique({\n    where: { id: claimId },\n    include: {\n      field: {\n        include: {\n          owner: {\n            select: {\n              id: true,\n              name: true,\n              email: true\n            }\n          }\n        }\n      }\n    }\n  });\n\n  if (!claim) {\n    throw new AppError('Claim not found', 404);\n  }\n\n  res.json({\n    success: true,\n    data: claim\n  });\n});\n\n// Update claim status (admin only)\nexport const updateClaimStatus = asyncHandler(async (req: Request, res: Response) => {\n  const { claimId } = req.params;\n  const { status, reviewNotes } = req.body;\n  const reviewerId = (req as any).user._id || (req as any).user.id;\n\n  if (!['APPROVED', 'REJECTED'].includes(status)) {\n    throw new AppError('Invalid status', 400);\n  }\n\n  const claim = await prisma.fieldClaim.findUnique({\n    where: { id: claimId },\n    include: {\n      field: {\n        select: {\n          id: true,\n          name: true,\n          address: true,\n          city: true,\n          state: true\n        }\n      }\n    }\n  });\n\n  if (!claim) {\n    throw new AppError('Claim not found', 404);\n  }\n\n  // Update the claim\n  const updatedClaim = await prisma.fieldClaim.update({\n    where: { id: claimId },\n    data: {\n      status,\n      reviewNotes,\n      reviewedAt: new Date(),\n      reviewedBy: reviewerId\n    }\n  });\n\n  // If approved, update the field's claim status\n  if (status === 'APPROVED') {\n    await prisma.field.update({\n      where: { id: claim.fieldId },\n      data: {\n        isClaimed: true\n      }\n    });\n  }\n\n  // Send email notification about status update\n  try {\n    const fieldAddress = claim.field.address ? \n      `${claim.field.address}${claim.field.city ? ', ' + claim.field.city : ''}${claim.field.state ? ', ' + claim.field.state : ''}` : \n      'Address not specified';\n    \n    await emailService.sendFieldClaimStatusEmail({\n      email: claim.email,\n      fullName: claim.fullName,\n      fieldName: claim.field.name || 'Unnamed Field',\n      fieldAddress: fieldAddress,\n      status: status as 'APPROVED' | 'REJECTED',\n      reviewNotes: reviewNotes,\n      documents: claim.documents // Include the documents array\n    });\n  } catch (emailError) {\n    // Log error but don't fail the status update\n    console.error('Failed to send field claim status email:', emailError);\n  }\n\n  res.json({\n    success: true,\n    message: `Claim ${status.toLowerCase()} successfully. An email notification has been sent to the claimer.`,\n    data: updatedClaim\n  });\n});\n\n// Check if a user can claim a field\nexport const checkClaimEligibility = asyncHandler(async (req: Request, res: Response) => {\n  const { fieldId } = req.params;\n  const { email } = req.query;\n\n  // Check if field exists\n  const field = await prisma.field.findUnique({\n    where: { id: fieldId }\n  });\n\n  if (!field) {\n    throw new AppError('Field not found', 404);\n  }\n\n  // Check if field is already claimed\n  if (field.isClaimed) {\n    return res.json({\n      success: true,\n      canClaim: false,\n      reason: 'This field has already been claimed and verified'\n    });\n  }\n\n  // Check if there's an approved claim\n  const approvedClaim = await prisma.fieldClaim.findFirst({\n    where: {\n      fieldId,\n      status: 'APPROVED'\n    }\n  });\n\n  if (approvedClaim) {\n    return res.json({\n      success: true,\n      canClaim: false,\n      reason: 'This field has already been claimed and approved'\n    });\n  }\n\n  // If email is provided, check if this user already has a pending claim\n  if (email) {\n    const userClaim = await prisma.fieldClaim.findFirst({\n      where: {\n        fieldId,\n        email: email as string,\n        status: 'PENDING'\n      }\n    });\n\n    if (userClaim) {\n      return res.json({\n        success: true,\n        canClaim: false,\n        reason: 'You already have a pending claim for this field',\n        userHasPendingClaim: true\n      });\n    }\n  }\n\n  // Count total pending claims for this field\n  const pendingClaimsCount = await prisma.fieldClaim.count({\n    where: {\n      fieldId,\n      status: 'PENDING'\n    }\n  });\n\n  res.json({\n    success: true,\n    canClaim: true,\n    pendingClaimsCount,\n    message: pendingClaimsCount > 0 \n      ? `This field has ${pendingClaimsCount} pending claim(s) under review. You can still submit your claim.`\n      : 'You can claim this field'\n  });\n});\n\n// Get claims for a specific field\nexport const getFieldClaims = asyncHandler(async (req: Request, res: Response) => {\n  const { fieldId } = req.params;\n\n  const claims = await prisma.fieldClaim.findMany({\n    where: { fieldId },\n    orderBy: {\n      createdAt: 'desc'\n    }\n  });\n\n  res.json({\n    success: true,\n    data: claims\n  });\n});"],"names":["checkClaimEligibility","getAllClaims","getClaimById","getFieldClaims","submitFieldClaim","updateClaimStatus","prisma","PrismaClient","asyncHandler","req","res","fieldId","fullName","email","phoneCode","phoneNumber","isLegalOwner","documents","body","undefined","length","AppError","field","findUnique","where","id","isClaimed","approvedClaim","fieldClaim","findFirst","status","existingUserClaim","claim","create","data","include","select","name","address","city","state","fieldAddress","fullPhoneNumber","emailService","sendFieldClaimEmail","fieldName","submittedAt","createdAt","emailError","console","error","json","success","message","page","limit","query","skip","Number","claims","total","Promise","all","findMany","orderBy","take","count","pagination","totalPages","Math","ceil","claimId","params","owner","reviewNotes","reviewerId","user","_id","includes","updatedClaim","update","reviewedAt","Date","reviewedBy","sendFieldClaimStatusEmail","toLowerCase","canClaim","reason","userClaim","userHasPendingClaim","pendingClaimsCount"],"mappings":"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"}