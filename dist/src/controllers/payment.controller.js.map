{"version":3,"sources":["../../../src/controllers/payment.controller.ts"],"sourcesContent":["import { Request, Response } from 'express';\nimport { stripe } from '../config/stripe.config';\nimport prisma from '../config/database';\nimport Stripe from 'stripe';\nimport { createNotification } from './notification.controller';\nimport { calculatePayoutAmounts } from '../utils/commission.utils';\nimport { subscriptionService } from '../services/subscription.service';\n\nexport class PaymentController {\n  // Create a payment intent for booking a field\n  async createPaymentIntent(req: Request, res: Response) {\n    try {\n      const {\n        fieldId,\n        numberOfDogs,\n        date,\n        timeSlot,\n        repeatBooking,\n        amount,\n        paymentMethodId // Optional: use saved payment method\n      } = req.body;\n\n      // Validate user\n      const userId = (req as any).user?.id;\n      if (!userId) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n\n      // Create idempotency key to prevent duplicate bookings\n      // Use a unique key for each payment intent attempt\n      const crypto = require('crypto');\n      const requestId = crypto.randomBytes(16).toString('hex');\n      const idempotencyKey = `booking_${userId}_${fieldId}_${date}_${timeSlot}_${requestId}`.replace(/[\\s:]/g, '_');\n      \n      // Check if a booking already exists for this exact combination\n      const existingBooking = await prisma.booking.findFirst({\n        where: {\n          userId,\n          fieldId,\n          date: new Date(date),\n          timeSlot,\n          status: {\n            notIn: ['CANCELLED']\n          }\n        }\n      });\n\n      if (existingBooking) {\n        console.log('Duplicate booking attempt detected:', {\n          userId,\n          fieldId,\n          date,\n          timeSlot,\n          existingBookingId: existingBooking.id\n        });\n        \n        // Check if the existing booking is already paid\n        if (existingBooking.paymentStatus === 'PAID' && existingBooking.status === 'CONFIRMED') {\n          // Return existing booking info instead of creating duplicate\n          return res.status(200).json({\n            paymentSucceeded: true,\n            bookingId: existingBooking.id,\n            message: 'Booking already exists and is confirmed',\n            isDuplicate: true\n          });\n        } else if (existingBooking.paymentStatus === 'PENDING') {\n          // If there's a pending booking, we can try to complete it\n          // but for safety, we'll still prevent duplicate creation\n          return res.status(200).json({\n            paymentSucceeded: false,\n            bookingId: existingBooking.id,\n            message: 'A booking for this slot is already being processed',\n            isDuplicate: true,\n            isPending: true\n          });\n        }\n      }\n\n      // Get user for Stripe customer\n      const user = await prisma.user.findUnique({\n        where: { id: userId }\n      });\n\n      if (!user) {\n        return res.status(404).json({ error: 'User not found' });\n      }\n\n      // Validate field exists\n      const field = await prisma.field.findUnique({\n        where: { id: fieldId }\n      });\n\n      if (!field) {\n        return res.status(404).json({ error: 'Field not found' });\n      }\n\n      // Calculate amount in cents (Stripe uses smallest currency unit)\n      const amountInCents = Math.round(amount * 100);\n      \n      // Calculate platform commission (20% for admin)\n      const PLATFORM_COMMISSION_RATE = 0.20; // 20% commission\n      const platformCommission = Math.round(amount * PLATFORM_COMMISSION_RATE * 100) / 100;\n      const fieldOwnerAmount = amount - platformCommission;\n\n      // Prepare payment intent parameters\n      // Payment goes to platform account (admin) first\n      const paymentIntentParams: Stripe.PaymentIntentCreateParams = {\n        amount: amountInCents,\n        currency: 'usd',\n        metadata: {\n          userId,\n          fieldId,\n          fieldOwnerId: field.ownerId || '',\n          numberOfDogs: numberOfDogs.toString(),\n          date,\n          timeSlot,\n          repeatBooking: repeatBooking || 'none',\n          type: 'field_booking',\n          platformCommission: platformCommission.toString(),\n          fieldOwnerAmount: fieldOwnerAmount.toString()\n        },\n        description: `Booking for ${field.name} on ${date} at ${timeSlot}`,\n        receipt_email: (req as any).user?.email,\n      };\n\n      // If a payment method is provided, use it\n      if (paymentMethodId) {\n        // Verify the payment method belongs to this user\n        const paymentMethod = await prisma.paymentMethod.findFirst({\n          where: {\n            id: paymentMethodId,\n            userId: userId\n          }\n        });\n\n        if (!paymentMethod) {\n          return res.status(400).json({ error: 'Invalid payment method' });\n        }\n\n        // Ensure user has a valid Stripe customer ID\n        let customerId = user.stripeCustomerId;\n        \n        // Verify customer exists in Stripe\n        if (customerId) {\n          try {\n            const customer = await stripe.customers.retrieve(customerId);\n            if ((customer as any).deleted) {\n              console.log(`Stripe customer ${customerId} was deleted, creating new one`);\n              customerId = null; // Force recreation\n            }\n          } catch (error: any) {\n            if (error.statusCode === 404 || error.code === 'resource_missing') {\n              console.log(`Stripe customer ${customerId} not found, creating new one`);\n              customerId = null; // Force recreation\n            } else {\n              throw error; // Re-throw other errors\n            }\n          }\n        }\n        \n        // Create customer if doesn't exist or was invalid\n        if (!customerId) {\n          const customer = await stripe.customers.create({\n            email: user.email,\n            name: user.name || undefined,\n            metadata: {\n              userId: user.id\n            }\n          });\n          customerId = customer.id;\n          \n          // Save customer ID\n          await prisma.user.update({\n            where: { id: userId },\n            data: { stripeCustomerId: customerId }\n          });\n        }\n\n        try {\n          // Verify the payment method still exists in Stripe\n          const stripePaymentMethod = await stripe.paymentMethods.retrieve(\n            paymentMethod.stripePaymentMethodId\n          );\n\n          // Check if payment method is attached to the customer\n          if (stripePaymentMethod.customer !== customerId) {\n            // Attach payment method to customer if not already attached\n            await stripe.paymentMethods.attach(\n              paymentMethod.stripePaymentMethodId,\n              { customer: customerId }\n            );\n          }\n        } catch (stripeError: any) {\n          console.error('Stripe payment method error:', stripeError);\n          \n          // Payment method doesn't exist or is invalid\n          if (stripeError.code === 'resource_missing' || stripeError.statusCode === 404) {\n            // Remove invalid payment method from database\n            await prisma.paymentMethod.delete({\n              where: { id: paymentMethodId }\n            });\n            \n            return res.status(400).json({ \n              error: 'Payment method no longer valid. Please add a new payment method.',\n              code: 'PAYMENT_METHOD_EXPIRED'\n            });\n          }\n          \n          // Other Stripe errors\n          return res.status(400).json({ \n            error: 'Unable to process payment method. Please try again or use a different payment method.',\n            code: 'PAYMENT_METHOD_ERROR'\n          });\n        }\n\n        paymentIntentParams.customer = customerId;\n        paymentIntentParams.payment_method = paymentMethod.stripePaymentMethodId;\n        paymentIntentParams.confirm = true; // Auto-confirm the payment\n        paymentIntentParams.return_url = `${process.env.FRONTEND_URL || 'http://localhost:3001'}/user/my-bookings`; // Add return URL for 3D Secure\n        // Use specific payment method configuration\n        paymentIntentParams.automatic_payment_methods = {\n          enabled: true,\n          allow_redirects: 'never' // Never allow redirect-based payment methods\n        };\n      } else {\n        // Use automatic payment methods for new card entry\n        paymentIntentParams.automatic_payment_methods = {\n          enabled: true,\n        };\n      }\n\n      // Create payment intent with error handling and idempotency\n      let paymentIntent;\n      try {\n        paymentIntent = await stripe.paymentIntents.create(paymentIntentParams, {\n          idempotencyKey: idempotencyKey\n        });\n      } catch (stripeError: any) {\n        console.error('Error creating payment intent:', stripeError);\n        \n        // Handle specific Stripe errors\n        if (stripeError.type === 'StripeInvalidRequestError') {\n          if (stripeError.message.includes('No such PaymentMethod')) {\n            return res.status(400).json({ \n              error: 'Payment method not found. Please select a different payment method.',\n              code: 'PAYMENT_METHOD_NOT_FOUND'\n            });\n          }\n          if (stripeError.message.includes('Payment method not available')) {\n            return res.status(400).json({ \n              error: 'This payment method is not available. Please try a different payment method.',\n              code: 'PAYMENT_METHOD_UNAVAILABLE'\n            });\n          }\n        }\n        \n        // Generic payment error\n        return res.status(500).json({ \n          error: 'Unable to process payment. Please try again.',\n          code: 'PAYMENT_PROCESSING_ERROR',\n          details: process.env.NODE_ENV === 'development' ? stripeError.message : undefined\n        });\n      }\n\n      // Parse the time slot to extract start and end times\n      // Expected format: \"4:00PM - 5:00PM\"\n      const [startTimeStr, endTimeStr] = timeSlot.split(' - ').map(t => t.trim());\n      \n      // Create a booking record with appropriate status\n      const bookingStatus = paymentIntent.status === 'succeeded' ? 'CONFIRMED' : 'PENDING';\n      const paymentStatus = paymentIntent.status === 'succeeded' ? 'PAID' : 'PENDING';\n      \n      // Check if field owner has a connected Stripe account\n      const fieldOwnerStripeAccount = await prisma.stripeAccount.findUnique({\n        where: { userId: field.ownerId }\n      });\n      \n      // Get system settings for payout release schedule\n      const systemSettings = await prisma.systemSettings.findFirst();\n      const payoutReleaseSchedule = systemSettings?.payoutReleaseSchedule || 'after_cancellation_window';\n      \n      // Determine payout status based on Stripe account connection and release schedule\n      let payoutStatus = 'PENDING';\n      let payoutHeldReason = undefined;\n      \n      if (paymentIntent.status === 'succeeded') {\n        if (!fieldOwnerStripeAccount || !fieldOwnerStripeAccount.chargesEnabled || !fieldOwnerStripeAccount.payoutsEnabled) {\n          // Hold the payout if field owner doesn't have a connected Stripe account\n          payoutStatus = 'HELD';\n          payoutHeldReason = 'NO_STRIPE_ACCOUNT';\n        } else if (payoutReleaseSchedule === 'immediate') {\n          // Process immediate payout if configured\n          payoutStatus = 'PENDING'; // Will be processed immediately after booking creation\n        } else if (payoutReleaseSchedule === 'on_weekend') {\n          // Check if today is weekend\n          const today = new Date().getDay();\n          if (today === 5 || today === 6 || today === 0) { // Friday, Saturday, Sunday\n            payoutStatus = 'PENDING';\n          } else {\n            payoutStatus = 'HELD';\n            payoutHeldReason = 'WAITING_FOR_WEEKEND';\n          }\n        } else { // after_cancellation_window\n          payoutStatus = 'HELD';\n          payoutHeldReason = 'WITHIN_CANCELLATION_WINDOW';\n        }\n      }\n      \n      const booking = await prisma.booking.create({\n        data: {\n          fieldId,\n          userId,\n          date: new Date(date),\n          startTime: startTimeStr,\n          endTime: endTimeStr,\n          timeSlot,\n          numberOfDogs: parseInt(numberOfDogs),\n          totalPrice: amount,\n          platformCommission,\n          fieldOwnerAmount,\n          status: bookingStatus,\n          paymentStatus: paymentStatus,\n          paymentIntentId: paymentIntent.id,\n          payoutStatus,\n          payoutHeldReason,\n          repeatBooking: repeatBooking || 'none'\n        }\n      });\n\n      // If payment was auto-confirmed with saved card, create notifications\n      if (paymentIntent.status === 'succeeded') {\n        // Create payment record\n        await prisma.payment.create({\n          data: {\n            bookingId: booking.id,\n            userId,\n            amount,\n            currency: 'USD',\n            status: 'completed',\n            paymentMethod: 'card',\n            stripePaymentId: paymentIntent.id,\n            processedAt: new Date()\n          }\n        });\n\n        // Send notifications\n        await createNotification({\n          userId,\n          type: 'BOOKING_CONFIRMATION',\n          title: 'Booking Confirmed',\n          message: `Your booking for ${field.name} on ${date} at ${timeSlot} has been confirmed.`,\n          data: { bookingId: booking.id, fieldId }\n        });\n\n        if (field.ownerId && field.ownerId !== userId) {\n          await createNotification({\n            userId: field.ownerId,\n            type: 'NEW_BOOKING',\n            title: 'New Booking',\n            message: `You have a new booking for ${field.name} on ${date} at ${timeSlot}.`,\n            data: { bookingId: booking.id, fieldId }\n          });\n        }\n        \n        // Process immediate payout if configured and Stripe account is connected\n        if (payoutReleaseSchedule === 'immediate' && fieldOwnerStripeAccount && \n            fieldOwnerStripeAccount.chargesEnabled && fieldOwnerStripeAccount.payoutsEnabled) {\n          try {\n            console.log(`Processing immediate payout for booking ${booking.id}`);\n            \n            // Create a transfer to the connected account\n            const transfer = await stripe.transfers.create({\n              amount: Math.round(fieldOwnerAmount * 100), // Convert to cents\n              currency: 'gbp',\n              destination: fieldOwnerStripeAccount.stripeAccountId,\n              transfer_group: `booking_${booking.id}`,\n              metadata: {\n                bookingId: booking.id,\n                fieldId: field.id,\n                fieldOwnerId: field.ownerId,\n                type: 'immediate_booking_payout',\n                processingReason: 'immediate_release_configured'\n              },\n              description: `Immediate payout for booking ${booking.id} - ${field.name}`\n            });\n\n            // Create payout record in database\n            const payout = await prisma.payout.create({\n              data: {\n                stripeAccountId: fieldOwnerStripeAccount.id,\n                stripePayoutId: transfer.id,\n                amount: fieldOwnerAmount,\n                currency: 'gbp',\n                status: 'paid',\n                method: 'standard',\n                description: `Immediate payout for booking ${booking.id}`,\n                bookingIds: [booking.id],\n                arrivalDate: new Date()\n              }\n            });\n\n            // Update booking with payout details\n            await prisma.booking.update({\n              where: { id: booking.id },\n              data: {\n                payoutStatus: 'COMPLETED',\n                payoutId: payout.id\n              }\n            });\n\n            // Notify field owner about immediate payout\n            await createNotification({\n              userId: field.ownerId,\n              type: 'PAYOUT_PROCESSED',\n              title: 'ðŸ’° Instant Payment Received!',\n              message: `Â£${fieldOwnerAmount.toFixed(2)} has been instantly transferred to your account for the ${field.name} booking.`,\n              data: {\n                bookingId: booking.id,\n                payoutId: payout.id,\n                amount: fieldOwnerAmount,\n                fieldName: field.name,\n                customerName: user.name || user.email\n              }\n            });\n            \n            console.log(`Immediate payout processed successfully for booking ${booking.id}`);\n          } catch (payoutError) {\n            console.error('Error processing immediate payout:', payoutError);\n            // Don't fail the booking, just log the error\n            // Payout will be retried by the scheduled job\n          }\n        }\n      }\n\n      res.json({\n        clientSecret: paymentIntent.client_secret,\n        bookingId: booking.id,\n        paymentSucceeded: paymentIntent.status === 'succeeded',\n        publishableKey: `pk_test_${process.env.STRIPE_SECRET_KEY?.slice(8, 40)}` // Send publishable key\n      });\n    } catch (error) {\n      console.error('Error creating payment intent:', error);\n      res.status(500).json({ \n        error: 'Failed to create payment intent',\n        details: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n\n  // Confirm payment and update booking status\n  async confirmPayment(req: Request, res: Response) {\n    try {\n      const { paymentIntentId, bookingId } = req.body;\n\n      // Retrieve the payment intent from Stripe\n      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);\n\n      if (paymentIntent.status === 'succeeded') {\n        // Update booking status\n        const booking = await prisma.booking.update({\n          where: { id: bookingId },\n          data: {\n            status: 'CONFIRMED',\n            paymentStatus: 'PAID'\n          },\n          include: {\n            field: true,\n            user: true\n          }\n        });\n\n        // Get field owner details first\n        const field = await prisma.field.findUnique({\n          where: { id: booking.fieldId },\n          include: {\n            owner: true\n          }\n        });\n\n        // Calculate commission amounts\n        const { fieldOwnerAmount, platformFeeAmount, commissionRate } = await calculatePayoutAmounts(\n          booking.totalPrice,\n          field?.ownerId || ''\n        );\n\n        // Create transaction record with commission details\n        await prisma.transaction.create({\n          data: {\n            bookingId: booking.id,\n            userId: booking.userId,\n            amount: booking.totalPrice,\n            netAmount: fieldOwnerAmount,\n            platformFee: platformFeeAmount,\n            commissionRate: commissionRate,\n            type: 'PAYMENT',\n            status: 'COMPLETED',\n            stripePaymentIntentId: paymentIntentId\n          }\n        });\n\n        // Send notification to field owner about new booking\n        if (field?.ownerId && field.ownerId !== booking.userId) {\n          await createNotification({\n            userId: field.ownerId,\n            type: 'new_booking_received',\n            title: 'New Booking Received!',\n            message: `You have a new booking for ${field.name} on ${new Date(booking.date).toLocaleDateString()} at ${booking.startTime}`,\n            data: {\n              bookingId: booking.id,\n              fieldId: booking.fieldId,\n              fieldName: field.name,\n              date: booking.date,\n              time: `${booking.startTime} - ${booking.endTime}`,\n              customerName: booking.user.name || booking.user.email,\n              numberOfDogs: booking.numberOfDogs,\n              amount: booking.totalPrice\n            }\n          });\n        }\n\n        // Send confirmation notification to dog owner\n        await createNotification({\n          userId: booking.userId,\n          type: 'booking_confirmed',\n          title: 'Booking Confirmed!',\n          message: `Your booking for ${field?.name || 'the field'} on ${new Date(booking.date).toLocaleDateString()} at ${booking.startTime} has been confirmed.`,\n          data: {\n            bookingId: booking.id,\n            fieldId: booking.fieldId,\n            fieldName: field?.name,\n            date: booking.date,\n            time: `${booking.startTime} - ${booking.endTime}`,\n            amount: booking.totalPrice,\n            paymentIntentId\n          }\n        });\n\n        // Send confirmation email (implement email service)\n        // await emailService.sendBookingConfirmation(booking);\n\n        res.json({\n          success: true,\n          booking,\n          message: 'Payment confirmed successfully'\n        });\n      } else {\n        res.status(400).json({\n          error: 'Payment not successful',\n          status: paymentIntent.status\n        });\n      }\n    } catch (error) {\n      console.error('Error confirming payment:', error);\n      res.status(500).json({ \n        error: 'Failed to confirm payment',\n        details: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n\n  // Handle Stripe webhooks\n  async handleWebhook(req: Request, res: Response) {\n    const sig = req.headers['stripe-signature'] as string;\n    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\n    if (!webhookSecret) {\n      console.error('Stripe webhook secret not configured');\n      return res.status(500).json({ error: 'Webhook secret not configured' });\n    }\n\n    let event: Stripe.Event;\n\n    try {\n      event = stripe.webhooks.constructEvent(\n        req.body,\n        sig,\n        webhookSecret\n      );\n    } catch (err) {\n      console.error('Webhook signature verification failed:', err);\n      return res.status(400).send(`Webhook Error: ${err instanceof Error ? err.message : 'Unknown error'}`);\n    }\n\n    // Handle the event\n    try {\n      switch (event.type) {\n        case 'payment_intent.succeeded':\n          const paymentIntent = event.data.object as Stripe.PaymentIntent;\n          \n          // Use transaction to prevent duplicate booking updates\n          await prisma.$transaction(async (tx) => {\n            // Check if booking exists\n            const booking = await tx.booking.findFirst({\n              where: { paymentIntentId: paymentIntent.id }\n            });\n\n            if (!booking) {\n              // If no booking exists with this payment intent ID, check metadata\n              // This handles edge cases where webhook arrives before booking creation\n              const metadata = paymentIntent.metadata;\n              if (metadata.userId && metadata.fieldId && metadata.date && metadata.timeSlot) {\n                // Check if a booking already exists for this exact combination\n                const existingBooking = await tx.booking.findFirst({\n                  where: {\n                    userId: metadata.userId,\n                    fieldId: metadata.fieldId,\n                    date: new Date(metadata.date),\n                    timeSlot: metadata.timeSlot,\n                    status: {\n                      notIn: ['CANCELLED']\n                    }\n                  }\n                });\n\n                if (existingBooking) {\n                  console.log('Webhook: Duplicate booking prevented for payment intent:', paymentIntent.id);\n                  // Update existing booking's payment intent if needed\n                  if (!existingBooking.paymentIntentId) {\n                    await tx.booking.update({\n                      where: { id: existingBooking.id },\n                      data: {\n                        paymentIntentId: paymentIntent.id,\n                        status: 'CONFIRMED',\n                        paymentStatus: 'PAID'\n                      }\n                    });\n                  }\n                  return; // Exit early to prevent duplicate\n                }\n\n                // Create new booking from webhook if it doesn't exist\n                const [startTimeStr, endTimeStr] = metadata.timeSlot.split(' - ').map((t: string) => t.trim());\n                const platformCommission = parseFloat(metadata.platformCommission || '0');\n                const fieldOwnerAmount = parseFloat(metadata.fieldOwnerAmount || '0');\n                \n                const newBooking = await tx.booking.create({\n                  data: {\n                    fieldId: metadata.fieldId,\n                    userId: metadata.userId,\n                    date: new Date(metadata.date),\n                    startTime: startTimeStr,\n                    endTime: endTimeStr,\n                    timeSlot: metadata.timeSlot,\n                    numberOfDogs: parseInt(metadata.numberOfDogs || '1'),\n                    totalPrice: paymentIntent.amount / 100, // Convert from cents\n                    platformCommission,\n                    fieldOwnerAmount,\n                    status: 'CONFIRMED',\n                    paymentStatus: 'PAID',\n                    paymentIntentId: paymentIntent.id,\n                    payoutStatus: 'PENDING',\n                    repeatBooking: metadata.repeatBooking || 'none'\n                  }\n                });\n\n                // Get field owner for commission calculation\n                const field = await tx.field.findUnique({\n                  where: { id: metadata.fieldId },\n                  select: { ownerId: true }\n                });\n\n                // Calculate commission amounts\n                const payoutAmounts = await calculatePayoutAmounts(\n                  paymentIntent.amount / 100,\n                  field?.ownerId || ''\n                );\n\n                // Create transaction record with commission details\n                await tx.transaction.create({\n                  data: {\n                    bookingId: newBooking.id,\n                    userId: metadata.userId,\n                    amount: paymentIntent.amount / 100,\n                    netAmount: payoutAmounts.fieldOwnerAmount,\n                    platformFee: payoutAmounts.platformFeeAmount,\n                    commissionRate: payoutAmounts.commissionRate,\n                    type: 'PAYMENT',\n                    status: 'COMPLETED',\n                    stripePaymentIntentId: paymentIntent.id\n                  }\n                });\n\n                console.log('Webhook: Created new booking from payment intent:', newBooking.id);\n              }\n            } else if (booking.status !== 'CONFIRMED' || booking.paymentStatus !== 'PAID') {\n              // Update existing booking status\n              await tx.booking.update({\n                where: { id: booking.id },\n                data: {\n                  status: 'CONFIRMED',\n                  paymentStatus: 'PAID'\n                }\n              });\n\n              // Check if transaction already exists\n              const existingTransaction = await tx.transaction.findFirst({\n                where: {\n                  stripePaymentIntentId: paymentIntent.id\n                }\n              });\n\n              if (!existingTransaction) {\n                // Get field for commission calculation\n                const field = await tx.field.findUnique({\n                  where: { id: booking.fieldId },\n                  select: { ownerId: true }\n                });\n\n                // Calculate commission amounts\n                const payoutAmounts = await calculatePayoutAmounts(\n                  booking.totalPrice,\n                  field?.ownerId || ''\n                );\n\n                // Create transaction record with commission details\n                await tx.transaction.create({\n                  data: {\n                    bookingId: booking.id,\n                    userId: booking.userId,\n                    amount: booking.totalPrice,\n                    netAmount: payoutAmounts.fieldOwnerAmount,\n                    platformFee: payoutAmounts.platformFeeAmount,\n                    commissionRate: payoutAmounts.commissionRate,\n                    type: 'PAYMENT',\n                    status: 'COMPLETED',\n                    stripePaymentIntentId: paymentIntent.id\n                  }\n                });\n              }\n            }\n          });\n          break;\n\n        case 'payment_intent.payment_failed':\n          const failedPayment = event.data.object as Stripe.PaymentIntent;\n          \n          // Update booking status to failed\n          const failedBooking = await prisma.booking.findFirst({\n            where: { paymentIntentId: failedPayment.id }\n          });\n\n          if (failedBooking) {\n            await prisma.booking.update({\n              where: { id: failedBooking.id },\n              data: {\n                status: 'CANCELLED',\n                paymentStatus: 'FAILED'\n              }\n            });\n          }\n          break;\n\n        default:\n          console.log(`Unhandled event type ${event.type}`);\n      }\n\n      res.json({ received: true });\n    } catch (error) {\n      console.error('Error processing webhook:', error);\n      res.status(500).json({ error: 'Webhook processing failed' });\n    }\n  }\n\n  // Get payment methods for user\n  async getPaymentMethods(req: Request, res: Response) {\n    try {\n      const userId = (req as any).user?.id;\n      \n      // For now, return mock data\n      // In production, integrate with Stripe Customer API\n      res.json({\n        paymentMethods: []\n      });\n    } catch (error) {\n      console.error('Error fetching payment methods:', error);\n      res.status(500).json({ error: 'Failed to fetch payment methods' });\n    }\n  }\n}"],"names":["PaymentController","createPaymentIntent","req","res","fieldId","numberOfDogs","date","timeSlot","repeatBooking","amount","paymentMethodId","body","userId","user","id","status","json","error","crypto","require","requestId","randomBytes","toString","idempotencyKey","replace","existingBooking","prisma","booking","findFirst","where","Date","notIn","console","log","existingBookingId","paymentStatus","paymentSucceeded","bookingId","message","isDuplicate","isPending","findUnique","field","amountInCents","Math","round","PLATFORM_COMMISSION_RATE","platformCommission","fieldOwnerAmount","paymentIntentParams","currency","metadata","fieldOwnerId","ownerId","type","description","name","receipt_email","email","paymentMethod","customerId","stripeCustomerId","customer","stripe","customers","retrieve","deleted","statusCode","code","create","undefined","update","data","stripePaymentMethod","paymentMethods","stripePaymentMethodId","attach","stripeError","delete","payment_method","confirm","return_url","process","env","FRONTEND_URL","automatic_payment_methods","enabled","allow_redirects","paymentIntent","paymentIntents","includes","details","NODE_ENV","startTimeStr","endTimeStr","split","map","t","trim","bookingStatus","fieldOwnerStripeAccount","stripeAccount","systemSettings","payoutReleaseSchedule","payoutStatus","payoutHeldReason","chargesEnabled","payoutsEnabled","today","getDay","startTime","endTime","parseInt","totalPrice","paymentIntentId","payment","stripePaymentId","processedAt","createNotification","title","transfer","transfers","destination","stripeAccountId","transfer_group","processingReason","payout","stripePayoutId","method","bookingIds","arrivalDate","payoutId","toFixed","fieldName","customerName","payoutError","clientSecret","client_secret","publishableKey","STRIPE_SECRET_KEY","slice","Error","confirmPayment","include","owner","platformFeeAmount","commissionRate","calculatePayoutAmounts","transaction","netAmount","platformFee","stripePaymentIntentId","toLocaleDateString","time","success","handleWebhook","sig","headers","webhookSecret","STRIPE_WEBHOOK_SECRET","event","webhooks","constructEvent","err","send","object","$transaction","tx","parseFloat","newBooking","select","payoutAmounts","existingTransaction","failedPayment","failedBooking","received","getPaymentMethods"],"mappings":"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"}