{"version":3,"sources":["../../../src/controllers/chat.controller.ts"],"sourcesContent":["import { Request, Response } from 'express';\nimport { PrismaClient } from '@prisma/client';\nimport { sendMessageToKafka } from '../config/kafka';\n\nconst prisma = new PrismaClient();\n\n// Get or create conversation\nexport const getOrCreateConversation = async (req: Request, res: Response) => {\n  try {\n    const { receiverId, fieldId } = req.body;\n    const senderId = (req as any).user.id;\n\n    if (!receiverId) {\n      return res.status(400).json({ error: 'Receiver ID is required' });\n    }\n\n    // Check if conversation already exists\n    let conversation = await prisma.conversation.findFirst({\n      where: {\n        participants: {\n          hasEvery: [senderId, receiverId]\n        },\n        fieldId: fieldId || undefined\n      },\n      include: {\n        field: {\n          select: {\n            id: true,\n            name: true,\n            images: true\n          }\n        }\n      }\n    });\n\n    if (!conversation) {\n      // Create new conversation\n      conversation = await prisma.conversation.create({\n        data: {\n          participants: [senderId, receiverId],\n          fieldId: fieldId || undefined\n        },\n        include: {\n          field: {\n            select: {\n              id: true,\n              name: true,\n              images: true\n            }\n          }\n        }\n      });\n    }\n\n    // Get participants info\n    const participants = await prisma.user.findMany({\n      where: {\n        id: {\n          in: [senderId, receiverId]\n        }\n      },\n      select: {\n        id: true,\n        name: true,\n        email: true,\n        image: true,\n        role: true\n      }\n    });\n\n    res.json({\n      ...conversation,\n      participants: participants\n    });\n  } catch (error) {\n    console.error('Error creating conversation:', error);\n    res.status(500).json({ error: 'Failed to create conversation' });\n  }\n};\n\n// Get user's conversations\nexport const getConversations = async (req: Request, res: Response) => {\n  try {\n    const userId = (req as any).user.id;\n    const { page = 1, limit = 20 } = req.query;\n    \n    const skip = (Number(page) - 1) * Number(limit);\n\n    const conversations = await prisma.conversation.findMany({\n      where: {\n        participants: {\n          has: userId\n        }\n      },\n      include: {\n        field: {\n          select: {\n            id: true,\n            name: true,\n            images: true\n          }\n        },\n        messages: {\n          take: 1,\n          orderBy: {\n            createdAt: 'desc'\n          },\n          include: {\n            sender: {\n              select: {\n                id: true,\n                name: true,\n                image: true\n              }\n            }\n          }\n        }\n      },\n      orderBy: {\n        lastMessageAt: 'desc'\n      },\n      skip,\n      take: Number(limit)\n    });\n\n    // Get participants info for each conversation\n    const conversationsWithParticipants = await Promise.all(\n      conversations.map(async (conv) => {\n        const participants = await prisma.user.findMany({\n          where: {\n            id: {\n              in: conv.participants\n            }\n          },\n          select: {\n            id: true,\n            name: true,\n            email: true,\n            image: true,\n            role: true\n          }\n        });\n\n        // Get unread count\n        const unreadCount = await prisma.message.count({\n          where: {\n            conversationId: conv.id,\n            receiverId: userId,\n            isRead: false\n          }\n        });\n\n        return {\n          ...conv,\n          participants,\n          unreadCount\n        };\n      })\n    );\n\n    // Get total count\n    const total = await prisma.conversation.count({\n      where: {\n        participants: {\n          has: userId\n        }\n      }\n    });\n\n    res.json({\n      conversations: conversationsWithParticipants,\n      pagination: {\n        page: Number(page),\n        limit: Number(limit),\n        total,\n        totalPages: Math.ceil(total / Number(limit))\n      }\n    });\n  } catch (error) {\n    console.error('Error fetching conversations:', error);\n    res.status(500).json({ error: 'Failed to fetch conversations' });\n  }\n};\n\n// Get messages for a conversation\nexport const getMessages = async (req: Request, res: Response) => {\n  try {\n    const { conversationId } = req.params;\n    const userId = (req as any).user.id;\n    const { page = 1, limit = 50 } = req.query;\n    \n    const skip = (Number(page) - 1) * Number(limit);\n\n    // Verify user is part of the conversation\n    const conversation = await prisma.conversation.findFirst({\n      where: {\n        id: conversationId,\n        participants: {\n          has: userId\n        }\n      }\n    });\n\n    if (!conversation) {\n      return res.status(403).json({ error: 'Access denied' });\n    }\n\n    // Get messages\n    const messages = await prisma.message.findMany({\n      where: {\n        conversationId\n      },\n      include: {\n        sender: {\n          select: {\n            id: true,\n            name: true,\n            image: true,\n            role: true\n          }\n        },\n        receiver: {\n          select: {\n            id: true,\n            name: true,\n            image: true,\n            role: true\n          }\n        }\n      },\n      orderBy: {\n        createdAt: 'desc'\n      },\n      skip,\n      take: Number(limit)\n    });\n\n    // Mark messages as read\n    await prisma.message.updateMany({\n      where: {\n        conversationId,\n        receiverId: userId,\n        isRead: false\n      },\n      data: {\n        isRead: true,\n        readAt: new Date()\n      }\n    });\n\n    // Get total count\n    const total = await prisma.message.count({\n      where: {\n        conversationId\n      }\n    });\n\n    res.json({\n      messages: messages.reverse(), // Reverse to get chronological order\n      pagination: {\n        page: Number(page),\n        limit: Number(limit),\n        total,\n        totalPages: Math.ceil(total / Number(limit))\n      }\n    });\n  } catch (error) {\n    console.error('Error fetching messages:', error);\n    res.status(500).json({ error: 'Failed to fetch messages' });\n  }\n};\n\n// Send a message\nexport const sendMessage = async (req: Request, res: Response) => {\n  try {\n    const { conversationId, content, receiverId } = req.body;\n    const senderId = (req as any).user.id;\n\n    if (!conversationId || !content || !receiverId) {\n      return res.status(400).json({ error: 'Missing required fields' });\n    }\n\n    // Verify user is part of the conversation\n    const conversation = await prisma.conversation.findFirst({\n      where: {\n        id: conversationId,\n        participants: {\n          has: senderId\n        }\n      }\n    });\n\n    if (!conversation) {\n      return res.status(403).json({ error: 'Access denied' });\n    }\n\n    // Check if users have blocked each other\n    const [senderBlockedReceiver, receiverBlockedSender] = await Promise.all([\n      prisma.userBlock.findUnique({\n        where: {\n          blockerId_blockedUserId: {\n            blockerId: senderId,\n            blockedUserId: receiverId\n          }\n        }\n      }),\n      prisma.userBlock.findUnique({\n        where: {\n          blockerId_blockedUserId: {\n            blockerId: receiverId,\n            blockedUserId: senderId\n          }\n        }\n      })\n    ]);\n\n    if (senderBlockedReceiver || receiverBlockedSender) {\n      return res.status(403).json({ \n        error: 'Cannot send messages. One or both users have blocked each other.',\n        blocked: true \n      });\n    }\n\n    // Send message to Kafka for processing\n    console.log('[Chat] Sending message:', { conversationId, senderId, receiverId, contentLength: content.length });\n    \n    const savedMessage = await sendMessageToKafka({\n      conversationId,\n      senderId,\n      receiverId,\n      content,\n      timestamp: new Date()\n    });\n\n    console.log('[Chat] Message sent successfully:', savedMessage?.id);\n    \n    // Return the saved message\n    res.json(savedMessage || { success: true, message: 'Message queued for delivery' });\n  } catch (error) {\n    console.error('Error sending message:', error);\n    res.status(500).json({ error: 'Failed to send message' });\n  }\n};\n\n// Get unread message count\nexport const getUnreadCount = async (req: Request, res: Response) => {\n  try {\n    const userId = (req as any).user.id;\n\n    const unreadCount = await prisma.message.count({\n      where: {\n        receiverId: userId,\n        isRead: false\n      }\n    });\n\n    res.json({ unreadCount });\n  } catch (error) {\n    console.error('Error fetching unread count:', error);\n    res.status(500).json({ error: 'Failed to fetch unread count' });\n  }\n};\n\n// Delete conversation\nexport const deleteConversation = async (req: Request, res: Response) => {\n  try {\n    const { conversationId } = req.params;\n    const userId = (req as any).user.id;\n\n    if (!conversationId) {\n      return res.status(400).json({ error: 'Conversation ID is required' });\n    }\n\n    // Verify user is part of the conversation\n    const conversation = await prisma.conversation.findFirst({\n      where: {\n        id: conversationId,\n        participants: {\n          has: userId\n        }\n      }\n    });\n\n    if (!conversation) {\n      return res.status(404).json({ error: 'Conversation not found' });\n    }\n\n    // Delete all messages in the conversation\n    await prisma.message.deleteMany({\n      where: {\n        conversationId\n      }\n    });\n\n    // Delete the conversation\n    await prisma.conversation.delete({\n      where: {\n        id: conversationId\n      }\n    });\n\n    res.json({ success: true, message: 'Conversation deleted successfully' });\n  } catch (error) {\n    console.error('Error deleting conversation:', error);\n    res.status(500).json({ error: 'Failed to delete conversation' });\n  }\n};"],"names":["deleteConversation","getConversations","getMessages","getOrCreateConversation","getUnreadCount","sendMessage","prisma","PrismaClient","req","res","receiverId","fieldId","body","senderId","user","id","status","json","error","conversation","findFirst","where","participants","hasEvery","undefined","include","field","select","name","images","create","data","findMany","in","email","image","role","console","userId","page","limit","query","skip","Number","conversations","has","messages","take","orderBy","createdAt","sender","lastMessageAt","conversationsWithParticipants","Promise","all","map","conv","unreadCount","message","count","conversationId","isRead","total","pagination","totalPages","Math","ceil","params","receiver","updateMany","readAt","Date","reverse","content","senderBlockedReceiver","receiverBlockedSender","userBlock","findUnique","blockerId_blockedUserId","blockerId","blockedUserId","blocked","log","contentLength","length","savedMessage","sendMessageToKafka","timestamp","success","deleteMany","delete"],"mappings":"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"}