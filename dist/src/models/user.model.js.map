{"version":3,"sources":["../../../src/models/user.model.ts"],"sourcesContent":["import prisma from '../config/database';\nimport bcrypt from 'bcryptjs';\nimport { BCRYPT_ROUNDS } from '../config/constants';\n\nexport interface CreateUserInput {\n  name: string;\n  email: string;\n  password: string;\n  role?: 'DOG_OWNER' | 'FIELD_OWNER' | 'ADMIN';\n  phone?: string;\n  provider?: string;\n}\n\nexport interface UpdateUserInput {\n  name?: string;\n  email?: string;\n  phone?: string;\n  bio?: string;\n  image?: string;\n}\n\nclass UserModel {\n  // Create a new user\n  async create(data: CreateUserInput) {\n    const hashedPassword = await bcrypt.hash(data.password, BCRYPT_ROUNDS);\n    const role = data.role || 'DOG_OWNER';\n    \n    // Get default commission rate from system settings for field owners\n    let commissionRate: number | undefined = undefined;\n    if (role === 'FIELD_OWNER') {\n      // Get system settings for default commission rate\n      const settings = await prisma.systemSettings.findFirst();\n      commissionRate = settings?.defaultCommissionRate || 15.0; // Use 15% as fallback\n    }\n    \n    return prisma.user.create({\n      data: {\n        ...data,\n        password: hashedPassword,\n        role,\n        provider: data.provider || 'general',\n        commissionRate,\n      },\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        role: true,\n        phone: true,\n        provider: true,\n        image: true,\n        googleImage: true,\n        commissionRate: true,\n        createdAt: true,\n        updatedAt: true,\n      },\n    });\n  }\n\n  // Find user by email (returns first match, use for login without role)\n  async findByEmail(email: string) {\n    return prisma.user.findFirst({\n      where: { email },\n    });\n  }\n  \n  // Find user by email and role\n  async findByEmailAndRole(email: string, role: 'DOG_OWNER' | 'FIELD_OWNER' | 'ADMIN') {\n    return prisma.user.findUnique({\n      where: {\n        email_role: {\n          email,\n          role\n        }\n      },\n    });\n  }\n\n  // Find user by phone\n  async findByPhone(phone: string) {\n    return prisma.user.findFirst({\n      where: { phone },\n    });\n  }\n\n  // Find user by ID\n  async findById(id: string) {\n    return prisma.user.findUnique({\n      where: { id },\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        role: true,\n        phone: true,\n        bio: true,\n        image: true,\n        googleImage: true,\n        provider: true,\n        emailVerified: true,\n        createdAt: true,\n        updatedAt: true,\n      },\n    });\n  }\n\n  // Update user\n  async update(id: string, data: UpdateUserInput) {\n    return prisma.user.update({\n      where: { id },\n      data,\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        role: true,\n        phone: true,\n        bio: true,\n        image: true,\n        googleImage: true,\n        provider: true,\n        createdAt: true,\n        updatedAt: true,\n      },\n    });\n  }\n\n  // Delete user\n  async delete(id: string) {\n    return prisma.user.delete({\n      where: { id },\n    });\n  }\n\n  // Verify password\n  async verifyPassword(plainPassword: string, hashedPassword: string) {\n    return bcrypt.compare(plainPassword, hashedPassword);\n  }\n\n  // Check if user has OAuth account\n  async hasOAuthAccount(userId: string) {\n    const account = await prisma.account.findFirst({\n      where: { userId },\n    });\n    return !!account;\n  }\n\n  // Get OAuth providers for a user\n  async getOAuthProviders(userId: string) {\n    const accounts = await prisma.account.findMany({\n      where: { userId },\n      select: { provider: true },\n    });\n    return accounts.map(a => a.provider);\n  }\n\n  // Get all users (admin only)\n  async findAll(skip = 0, take = 10) {\n    return prisma.user.findMany({\n      skip,\n      take,\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        role: true,\n        phone: true,\n        image: true,\n        googleImage: true,\n        createdAt: true,\n        updatedAt: true,\n      },\n      orderBy: {\n        createdAt: 'desc',\n      },\n    });\n  }\n\n  // Create or update user from social login\n  async createOrUpdateSocialUser(data: {\n    email: string;\n    name?: string;\n    image?: string;\n    provider: string;\n    providerId: string;\n    role?: 'DOG_OWNER' | 'FIELD_OWNER' | 'ADMIN';\n  }) {\n    const userRole = data.role || 'DOG_OWNER';\n    \n    // Check if user exists with same email and role\n    const existingUser = await this.findByEmailAndRole(data.email, userRole);\n    \n    if (existingUser) {\n      // Update existing user with social login info\n      const updateData: any = {\n        name: data.name || existingUser.name,\n        // Keep user's uploaded image, store Google image separately\n        image: existingUser.image, // Keep existing uploaded image\n        emailVerified: new Date(), // Social logins are verified\n        provider: data.provider, // Update provider to track social login\n      };\n      \n      // Store Google image separately if provider is Google\n      if (data.provider === 'google' && data.image) {\n        updateData.googleImage = data.image;\n        // Only use Google image as primary if user has no uploaded image\n        if (!existingUser.image) {\n          updateData.image = data.image;\n        }\n      }\n      \n      return prisma.user.update({\n        where: { id: existingUser.id },\n        data: updateData,\n        select: {\n          id: true,\n          email: true,\n          name: true,\n          role: true,\n          phone: true,\n          provider: true,\n          image: true,\n          googleImage: true,\n          createdAt: true,\n          updatedAt: true,\n        },\n      });\n    }\n    \n    // Create new user from social login with specific role\n    const createData: any = {\n      email: data.email,\n      name: data.name || data.email.split('@')[0],\n      image: data.image,\n      role: userRole,\n      provider: data.provider,\n      emailVerified: new Date(), // Social logins are verified\n    };\n    \n    // Store Google image separately if provider is Google\n    if (data.provider === 'google' && data.image) {\n      createData.googleImage = data.image;\n    }\n    \n    return prisma.user.create({\n      data: createData,\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        role: true,\n        phone: true,\n        provider: true,\n        image: true,\n        googleImage: true,\n        createdAt: true,\n        updatedAt: true,\n      },\n    });\n  }\n  // Update user role\n  async updateRole(id: string, role: 'DOG_OWNER' | 'FIELD_OWNER' | 'ADMIN') {\n    return prisma.user.update({\n      where: { id },\n      data: { role },\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        role: true,\n        phone: true,\n        provider: true,\n        image: true,\n        googleImage: true,\n        createdAt: true,\n        updatedAt: true,\n      },\n    });\n  }\n}\n\nexport default new UserModel();"],"names":["UserModel","create","data","hashedPassword","bcrypt","hash","password","BCRYPT_ROUNDS","role","commissionRate","undefined","settings","prisma","systemSettings","findFirst","defaultCommissionRate","user","provider","select","id","email","name","phone","image","googleImage","createdAt","updatedAt","findByEmail","where","findByEmailAndRole","findUnique","email_role","findByPhone","findById","bio","emailVerified","update","delete","verifyPassword","plainPassword","compare","hasOAuthAccount","userId","account","getOAuthProviders","accounts","findMany","map","a","findAll","skip","take","orderBy","createOrUpdateSocialUser","userRole","existingUser","updateData","Date","createData","split","updateRole"],"mappings":"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"}