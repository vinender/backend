{"version":3,"sources":["../../../src/services/subscription.service.ts"],"sourcesContent":["import { stripe } from '../config/stripe.config';\nimport prisma from '../config/database';\nimport Stripe from 'stripe';\nimport { createNotification } from '../controllers/notification.controller';\nimport { addDays, addMonths, format, parse } from 'date-fns';\n\nexport class SubscriptionService {\n  /**\n   * Create a Stripe subscription for recurring bookings\n   */\n  async createSubscription({\n    userId,\n    fieldId,\n    date,\n    timeSlot,\n    startTime,\n    endTime,\n    numberOfDogs,\n    repeatBooking,\n    amount,\n    paymentMethodId,\n    customerEmail\n  }: {\n    userId: string;\n    fieldId: string;\n    date: string;\n    timeSlot: string;\n    startTime: string;\n    endTime: string;\n    numberOfDogs: number;\n    repeatBooking: 'weekly' | 'monthly';\n    amount: number;\n    paymentMethodId: string;\n    customerEmail: string;\n  }) {\n    // Get user and field\n    const [user, field] = await Promise.all([\n      prisma.user.findUnique({ where: { id: userId } }),\n      prisma.field.findUnique({ where: { id: fieldId } })\n    ]);\n\n    if (!user || !field) {\n      throw new Error('User or field not found');\n    }\n\n    // Ensure user has a Stripe customer ID\n    let customerId = user.stripeCustomerId;\n    if (!customerId) {\n      const customer = await stripe.customers.create({\n        email: customerEmail,\n        name: user.name || undefined,\n        metadata: { userId: user.id }\n      });\n      customerId = customer.id;\n      \n      await prisma.user.update({\n        where: { id: userId },\n        data: { stripeCustomerId: customerId }\n      });\n    }\n\n    // Attach payment method to customer\n    await stripe.paymentMethods.attach(paymentMethodId, {\n      customer: customerId\n    });\n\n    // Set as default payment method\n    await stripe.customers.update(customerId, {\n      invoice_settings: {\n        default_payment_method: paymentMethodId\n      }\n    });\n\n    // Calculate commission\n    const PLATFORM_COMMISSION_RATE = 0.20;\n    const platformCommission = Math.round(amount * PLATFORM_COMMISSION_RATE * 100) / 100;\n    const fieldOwnerAmount = amount - platformCommission;\n\n    // Parse the date to get day of week/month\n    const bookingDate = new Date(date);\n    const dayOfWeek = format(bookingDate, 'EEEE'); // Monday, Tuesday, etc.\n    const dayOfMonth = bookingDate.getDate();\n\n    // Create Stripe product for this field\n    const product = await stripe.products.create({\n      name: `${field.name} - ${timeSlot}`,\n      metadata: {\n        fieldId: field.id,\n        fieldName: field.name || '',\n        timeSlot,\n        numberOfDogs: numberOfDogs.toString()\n      }\n    });\n\n    // Create price based on interval\n    const priceData: Stripe.PriceCreateParams = {\n      product: product.id,\n      unit_amount: Math.round(amount * 100), // Convert to cents\n      currency: 'usd',\n      recurring: {\n        interval: repeatBooking === 'weekly' ? 'week' : 'month',\n        interval_count: 1\n      },\n      metadata: {\n        fieldId: field.id,\n        userId: user.id,\n        platformCommission: platformCommission.toString(),\n        fieldOwnerAmount: fieldOwnerAmount.toString()\n      }\n    };\n\n    const price = await stripe.prices.create(priceData);\n\n    // Calculate subscription start date (next occurrence)\n    let subscriptionStartDate = new Date();\n    if (repeatBooking === 'weekly') {\n      // Find next occurrence of the selected day\n      subscriptionStartDate = this.getNextWeeklyDate(bookingDate);\n    } else {\n      // Monthly - next month on the same date\n      subscriptionStartDate = this.getNextMonthlyDate(bookingDate);\n    }\n\n    // Create the subscription\n    const subscription = await stripe.subscriptions.create({\n      customer: customerId,\n      items: [{ price: price.id }],\n      metadata: {\n        userId: user.id,\n        fieldId: field.id,\n        fieldOwnerId: field.ownerId || '',\n        timeSlot,\n        startTime,\n        endTime,\n        numberOfDogs: numberOfDogs.toString(),\n        dayOfWeek: repeatBooking === 'weekly' ? dayOfWeek : '',\n        dayOfMonth: repeatBooking === 'monthly' ? dayOfMonth.toString() : '',\n        interval: repeatBooking,\n        platformCommission: platformCommission.toString(),\n        fieldOwnerAmount: fieldOwnerAmount.toString()\n      },\n      payment_behavior: 'default_incomplete',\n      payment_settings: {\n        save_default_payment_method: 'on_subscription'\n      },\n      expand: ['latest_invoice.payment_intent']\n    });\n\n    // Store subscription in database\n    const dbSubscription = await prisma.subscription.create({\n      data: {\n        userId,\n        fieldId,\n        stripeSubscriptionId: subscription.id,\n        stripeCustomerId: customerId,\n        status: subscription.status,\n        interval: repeatBooking,\n        intervalCount: 1,\n        currentPeriodStart: new Date(subscription.current_period_start * 1000),\n        currentPeriodEnd: new Date(subscription.current_period_end * 1000),\n        timeSlot,\n        dayOfWeek: repeatBooking === 'weekly' ? dayOfWeek : null,\n        dayOfMonth: repeatBooking === 'monthly' ? dayOfMonth : null,\n        startTime,\n        endTime,\n        numberOfDogs,\n        totalPrice: amount,\n        nextBillingDate: new Date(subscription.current_period_end * 1000)\n      }\n    });\n\n    // Create the first booking\n    await this.createBookingFromSubscription(dbSubscription.id, bookingDate);\n\n    // Send notification to field owner\n    if (field.ownerId && field.ownerId !== userId) {\n      await createNotification({\n        userId: field.ownerId,\n        type: 'recurring_booking_created',\n        title: 'New Recurring Booking!',\n        message: `A ${repeatBooking} recurring booking has been set up for ${field.name} starting ${format(bookingDate, 'PPP')} at ${timeSlot}`,\n        data: {\n          subscriptionId: dbSubscription.id,\n          fieldId: field.id,\n          fieldName: field.name,\n          interval: repeatBooking\n        }\n      });\n    }\n\n    return {\n      subscription: dbSubscription,\n      stripeSubscription: subscription,\n      clientSecret: (subscription.latest_invoice as any)?.payment_intent?.client_secret\n    };\n  }\n\n  /**\n   * Create a booking from a subscription\n   */\n  async createBookingFromSubscription(subscriptionId: string, bookingDate: Date) {\n    const subscription = await prisma.subscription.findUnique({\n      where: { id: subscriptionId },\n      include: { field: true }\n    });\n\n    if (!subscription) {\n      throw new Error('Subscription not found');\n    }\n\n    // Calculate price based on field duration\n    const { field } = subscription;\n    const pricePerUnit = field.price || 0;\n    const [startHour, startMin] = subscription.startTime.split(':').map(Number);\n    const [endHour, endMin] = subscription.endTime.split(':').map(Number);\n    const durationHours = (endHour * 60 + endMin - startHour * 60 - startMin) / 60;\n    \n    let totalPrice = 0;\n    if (field.bookingDuration === '30min') {\n      const duration30MinBlocks = durationHours * 2;\n      totalPrice = pricePerUnit * duration30MinBlocks * subscription.numberOfDogs;\n    } else {\n      totalPrice = pricePerUnit * durationHours * subscription.numberOfDogs;\n    }\n\n    // Create booking\n    const booking = await prisma.booking.create({\n      data: {\n        userId: subscription.userId,\n        fieldId: subscription.fieldId,\n        date: bookingDate,\n        startTime: this.formatTimeForBooking(subscription.startTime),\n        endTime: this.formatTimeForBooking(subscription.endTime),\n        timeSlot: subscription.timeSlot,\n        numberOfDogs: subscription.numberOfDogs,\n        totalPrice,\n        status: 'CONFIRMED',\n        paymentStatus: 'PAID',\n        repeatBooking: subscription.interval,\n        subscriptionId: subscription.id,\n        platformCommission: totalPrice * 0.20,\n        fieldOwnerAmount: totalPrice * 0.80\n      }\n    });\n\n    // Update subscription last booking date\n    await prisma.subscription.update({\n      where: { id: subscriptionId },\n      data: { lastBookingDate: bookingDate }\n    });\n\n    return booking;\n  }\n\n  /**\n   * Handle subscription webhook events from Stripe\n   */\n  async handleSubscriptionWebhook(event: Stripe.Event) {\n    switch (event.type) {\n      case 'invoice.payment_succeeded':\n        await this.handleInvoicePaymentSucceeded(event.data.object as Stripe.Invoice);\n        break;\n      \n      case 'invoice.payment_failed':\n        await this.handleInvoicePaymentFailed(event.data.object as Stripe.Invoice);\n        break;\n      \n      case 'customer.subscription.updated':\n        await this.handleSubscriptionUpdated(event.data.object as Stripe.Subscription);\n        break;\n      \n      case 'customer.subscription.deleted':\n        await this.handleSubscriptionDeleted(event.data.object as Stripe.Subscription);\n        break;\n    }\n  }\n\n  /**\n   * Handle successful invoice payment (create next booking)\n   */\n  private async handleInvoicePaymentSucceeded(invoice: Stripe.Invoice) {\n    if (!invoice.subscription) return;\n\n    const subscription = await prisma.subscription.findUnique({\n      where: { stripeSubscriptionId: invoice.subscription as string }\n    });\n\n    if (!subscription) return;\n\n    // Calculate next booking date\n    let nextBookingDate = new Date();\n    if (subscription.interval === 'weekly') {\n      // Next week on the same day\n      nextBookingDate = addDays(subscription.lastBookingDate || new Date(), 7);\n    } else {\n      // Next month on the same date\n      nextBookingDate = addMonths(subscription.lastBookingDate || new Date(), 1);\n    }\n\n    // Create the booking for the next period\n    await this.createBookingFromSubscription(subscription.id, nextBookingDate);\n\n    // Send notification to user\n    await createNotification({\n      userId: subscription.userId,\n      type: 'recurring_booking_charged',\n      title: 'Recurring Booking Renewed',\n      message: `Your ${subscription.interval} booking has been renewed. Next booking: ${format(nextBookingDate, 'PPP')} at ${subscription.timeSlot}`,\n      data: {\n        subscriptionId: subscription.id,\n        nextBookingDate: nextBookingDate.toISOString()\n      }\n    });\n  }\n\n  /**\n   * Handle failed invoice payment\n   */\n  private async handleInvoicePaymentFailed(invoice: Stripe.Invoice) {\n    if (!invoice.subscription) return;\n\n    const subscription = await prisma.subscription.findUnique({\n      where: { stripeSubscriptionId: invoice.subscription as string }\n    });\n\n    if (!subscription) return;\n\n    // Update subscription status\n    await prisma.subscription.update({\n      where: { id: subscription.id },\n      data: { status: 'past_due' }\n    });\n\n    // Send notification to user\n    await createNotification({\n      userId: subscription.userId,\n      type: 'payment_failed',\n      title: 'Payment Failed',\n      message: 'Your recurring booking payment failed. Please update your payment method to continue.',\n      data: {\n        subscriptionId: subscription.id\n      }\n    });\n  }\n\n  /**\n   * Handle subscription updates from Stripe\n   */\n  private async handleSubscriptionUpdated(stripeSubscription: Stripe.Subscription) {\n    await prisma.subscription.update({\n      where: { stripeSubscriptionId: stripeSubscription.id },\n      data: {\n        status: stripeSubscription.status,\n        currentPeriodStart: new Date(stripeSubscription.current_period_start * 1000),\n        currentPeriodEnd: new Date(stripeSubscription.current_period_end * 1000),\n        cancelAtPeriodEnd: stripeSubscription.cancel_at_period_end,\n        canceledAt: stripeSubscription.canceled_at ? new Date(stripeSubscription.canceled_at * 1000) : null\n      }\n    });\n  }\n\n  /**\n   * Handle subscription deletion\n   */\n  private async handleSubscriptionDeleted(stripeSubscription: Stripe.Subscription) {\n    const subscription = await prisma.subscription.update({\n      where: { stripeSubscriptionId: stripeSubscription.id },\n      data: {\n        status: 'canceled',\n        canceledAt: new Date()\n      }\n    });\n\n    // Send notification to user\n    await createNotification({\n      userId: subscription.userId,\n      type: 'subscription_canceled',\n      title: 'Recurring Booking Cancelled',\n      message: 'Your recurring booking has been cancelled.',\n      data: {\n        subscriptionId: subscription.id\n      }\n    });\n  }\n\n  /**\n   * Cancel a subscription\n   */\n  async cancelSubscription(subscriptionId: string, cancelImmediately = false) {\n    const subscription = await prisma.subscription.findUnique({\n      where: { id: subscriptionId }\n    });\n\n    if (!subscription) {\n      throw new Error('Subscription not found');\n    }\n\n    // Cancel in Stripe\n    const stripeSubscription = await stripe.subscriptions.update(\n      subscription.stripeSubscriptionId,\n      {\n        cancel_at_period_end: !cancelImmediately\n      }\n    );\n\n    if (cancelImmediately) {\n      await stripe.subscriptions.cancel(subscription.stripeSubscriptionId);\n    }\n\n    // Update in database\n    await prisma.subscription.update({\n      where: { id: subscriptionId },\n      data: {\n        cancelAtPeriodEnd: !cancelImmediately,\n        status: cancelImmediately ? 'canceled' : subscription.status,\n        canceledAt: cancelImmediately ? new Date() : null\n      }\n    });\n\n    return stripeSubscription;\n  }\n\n  /**\n   * Get next weekly occurrence of a date\n   */\n  private getNextWeeklyDate(date: Date): Date {\n    return addDays(date, 7);\n  }\n\n  /**\n   * Get next monthly occurrence of a date\n   */\n  private getNextMonthlyDate(date: Date): Date {\n    return addMonths(date, 1);\n  }\n\n  /**\n   * Format time for booking (e.g., \"08:00\" to \"8:00AM\")\n   */\n  private formatTimeForBooking(time: string): string {\n    const [hours, minutes] = time.split(':').map(Number);\n    const period = hours >= 12 ? 'PM' : 'AM';\n    const displayHour = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;\n    return `${displayHour}:${minutes.toString().padStart(2, '0')}${period}`;\n  }\n}\n\nexport const subscriptionService = new SubscriptionService();"],"names":["SubscriptionService","subscriptionService","createSubscription","userId","fieldId","date","timeSlot","startTime","endTime","numberOfDogs","repeatBooking","amount","paymentMethodId","customerEmail","user","field","Promise","all","prisma","findUnique","where","id","Error","customerId","stripeCustomerId","customer","stripe","customers","create","email","name","undefined","metadata","update","data","paymentMethods","attach","invoice_settings","default_payment_method","PLATFORM_COMMISSION_RATE","platformCommission","Math","round","fieldOwnerAmount","bookingDate","Date","dayOfWeek","format","dayOfMonth","getDate","product","products","fieldName","toString","priceData","unit_amount","currency","recurring","interval","interval_count","price","prices","subscriptionStartDate","getNextWeeklyDate","getNextMonthlyDate","subscription","subscriptions","items","fieldOwnerId","ownerId","payment_behavior","payment_settings","save_default_payment_method","expand","dbSubscription","stripeSubscriptionId","status","intervalCount","currentPeriodStart","current_period_start","currentPeriodEnd","current_period_end","totalPrice","nextBillingDate","createBookingFromSubscription","createNotification","type","title","message","subscriptionId","stripeSubscription","clientSecret","latest_invoice","payment_intent","client_secret","include","pricePerUnit","startHour","startMin","split","map","Number","endHour","endMin","durationHours","bookingDuration","duration30MinBlocks","booking","formatTimeForBooking","paymentStatus","lastBookingDate","handleSubscriptionWebhook","event","handleInvoicePaymentSucceeded","object","handleInvoicePaymentFailed","handleSubscriptionUpdated","handleSubscriptionDeleted","invoice","nextBookingDate","addDays","addMonths","toISOString","cancelAtPeriodEnd","cancel_at_period_end","canceledAt","canceled_at","cancelSubscription","cancelImmediately","cancel","time","hours","minutes","period","displayHour","padStart"],"mappings":"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"}